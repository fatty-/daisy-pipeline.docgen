<html><head><style type="text/css">
                    body {
                        font-family : futura, helvetica, arial, sans-serif;
                    }
                    section,
                    article,
                    header,
                    footer,
                    nav,
                    aside,
                    hgroup {
                        display : block;
                    }
                    section.reference {
                        border-style : solid;
                        border-width : 1px;
                        border-radius : 10px;
                        -moz-border-radius : 10px;
                        margin : 5px;
                        padding : 20px;
                        border-color : #CCC;
                        background-color : #F9F9F9;
                    }
                    .child-topics section.reference {
                        border-style : solid;
                        border-width : 2px;
                        border-radius : 10px;
                        -moz-border-radius : 10px;
                        margin : 20px;
                        padding : 20px;
                        border-color : #CCC;
                        background-color : #EEF;
                    }
                    section.child-topics {
                        margin-left : 25px;
                    }
                    .main-header h1 {
                        width : 100%;
                        border-style : solid;
                        border-width : 0px 0px 1px 0px;
                        font-size : 26px;
                    }
                    table {
                        margin : 10px;
                    }
                    table.parml {
                        border-style : solid;
                        border-width : 1px;
                        border-color : white;
                        background-color : #EEF;
                    }
                    tr.plentry {
                        border-style : dotted;
                        border-width : 1px;
                    }
                    td.pt td.pd {
                        padding : 5px;
                        border-style : solid;
                        border-width : 1px;
                        border-radius : 4px;
                    }
                    .reference h1 {
                        font-size : 22px;
                        color : #006;
                    }
                    section.abstract,
                    section.prolog,
                    section.parameters,
                    section.linklist,
                    section.sourcecode {
                        border-style : dotted;
                        border-width : 1px;
                        border-radius : 0px;
                        margin : 10px;
                        padding : 10px 10px 50px 10px;
                        background-color : #F5F5FF;
                    }
                    section.sourcecode {
                        /*display: none;*/
                    }
                    header.abstract-header,
                    header.prolog-header,
                    header.io-header,
                    .linklist header,
                    header.sourcecode-header {
                        position : relative;
                        top : -30px;
                        float : left;
                    }
                    .abstract-header h1,
                    .prolog-header h1,
                    .io-header h1,
                    .linklist h1,
                    .sourcecode-header h1 {
                        position : absolute;
                        color : #006;
                        background-color : #EEF;
                        font-size : 18px;
                        white-space : nowrap;
                    }
                    header.subheader {
                        position : static;
                        top : 0px;
                        float : none;
                    }
                    .subheader h1 {
                        color : #006;
                        background-color : transparent;
                        font-size : 16px;
                    }</style></head><header class="main-header"><h1>source2dita/xproc/xpdoc.xsl</h1></header>
   <section class="reference XSLT "><header class="title "><h1>xsl:stylesheet</h1></header><p class="shortdesc ">Transforms the input XProc document to a DITA Reference Topic.</p><section class="prolog "><header class="prolog-header"><h1>About</h1></header>
      <p class="">Author: Jostein Austvik Jacobsen, NLB, josteinaj@gmail.com</p>
      <p class="copyright "> Â© <span class="copyrholder "/>, <span class="copyryear ">2010</span></p>
      <table class="metadata ">
         
         <tr class="othermeta "><td>Programming language</td><td>XSLT</td></tr>
         <tr class="othermeta "><td>Version</td><td>0.1</td></tr>
         <tr class="othermeta "><td>XSLT version</td><td>2.0</td></tr>
         <tr class="othermeta "><td>XPath version</td><td>2.0</td></tr>
      </table>
   </section>
      <section class="section ">
         
      </section>
      <section class="section parameters xslt-outputs">
         <header class="title io-header"><h1>Outputs (xsl:output)</h1></header>
         <table class="parml xslt-outputs"><tr><th>name</th><th>method</th><th>indent</th><th>doctype-system</th><th>doctype-public</th><th>include-content-type</th><th>encoding</th><th>media-type</th><th>omit-xml-declaration</th><th>standalone</th><th>version</th><th>description</th></tr>
            <td class="pt "/>
            <td class="pt ">xml</td>
            <td class="pt ">yes</td>
            <td class="pt "/>
            <td class="pt "/>
            <td class="pt ">yes</td>
            <td class="pt ">UTF-8</td>
            <td class="pt ">text/xml</td>
            <td class="pt ">no</td>
            <td class="pt ">omit</td>
            <td class="pt "/>
            <td class="pd "/>
         </table>
      </section>
   <span class="related-links ">
      <section class="linklist "><header class="title "><h1>Dependencies (xsl:import)</h1></header><p class="linkinfo ">These dependencies are derived from the xsl:import statements.</p><p class="link "><a href="../../lib/xml-to-string.xsl.html" style="padding-left: 20px; background: transparent url(../../img/xslt.png) no-repeat center left;">../../lib/xml-to-string.xsl</a></p></section>
   </span></section><section class="child-topics">
      <section class="reference XSLT "><header class="title "><h1>xsl:template</h1></header><p class="shortdesc ">Override the "/" template in xml-to-string.xsl.</p><section class="section sourcecode">
      <header class="title sourcecode-header"><h1>Source Code</h1></header>
      <pre class="codeblock"><code class="">&lt;xsl:template xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:p="http://www.w3.org/ns/xproc" xmlns:xd="http://pipeline.daisy.org/ns/sample/doc" match="/"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;</code></pre>
   </section></section>
      <section class="reference XSLT "><header class="title "><h1>xsl:template</h1></header><p class="shortdesc ">Identity template.</p><section class="section sourcecode">
      <header class="title sourcecode-header"><h1>Source Code</h1></header>
      <pre class="codeblock"><code class="">&lt;xsl:template xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:p="http://www.w3.org/ns/xproc" xmlns:xd="http://pipeline.daisy.org/ns/sample/doc" match="@*|node()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;</code></pre>
   </section></section>
      <section class="reference XSLT "><header class="title "><h1>xsl:template</h1></header><p class="shortdesc ">Main template</p><section class="abstract "><header class="abstract-header"><h1>Description</h1></header><p>
      
    
    Creates the top element &lt;dita&gt;, determines how to document the XProc script
      itself, and recurses throught the code looking for p:documentation elements.
  </p></section><section class="section sourcecode">
      <header class="title sourcecode-header"><h1>Source Code</h1></header>
      <pre class="codeblock"><code class="">&lt;xsl:template xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:p="http://www.w3.org/ns/xproc" xmlns:xd="http://pipeline.daisy.org/ns/sample/doc" match="/*"&gt;
    &lt;dita&gt;
      &lt;xsl:choose&gt;

        &lt;!-- When the root element contains a p:documentation child targeting it, use it --&gt;
        &lt;xsl:when test="./p:documentation[@xd:target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./p:documentation[@xd:target='parent'][1]"/&gt;
          &lt;xsl:call-template name="pipedoc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- When the first child of the root element is a p:documentation and is not targeting another element, use it --&gt;
        &lt;xsl:when test="name(./*[1]) = 'p:documentation' and not(./*[1]/@xd:target = 'following')"&gt;
          &lt;xsl:variable name="parentdoc" select="./*[1]"/&gt;
          &lt;xsl:call-template name="pipedoc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- The root element is not documented. Create some empty documentation for it. --&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:call-template name="pipedoc"&gt;
            &lt;xsl:with-param name="doc"&gt;
              &lt;p:documentation/&gt;
            &lt;/xsl:with-param&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:otherwise&gt;

      &lt;/xsl:choose&gt;
    &lt;/dita&gt;
  &lt;/xsl:template&gt;</code></pre>
   </section></section>
      <section class="reference XSLT "><header class="title "><h1>xsl:template - subdoc</h1></header><p class="shortdesc ">Recursive template that looks for p:documentation elements.</p><section class="abstract "><header class="abstract-header"><h1>Description</h1></header><p>
      
    
    If there is a p:documentation belonging to the current element; document the current
      element using it. At the same time; recurse further through the script looking for more
      elements to be documented.
    
    
  </p></section>
      <section class="section ">
         
      </section>
      <section class="section parameters xslt-params">
         <header class="title io-header"><h1>Parameters (xsl:param / xsl:with-param)</h1></header>
         <table class="parml xslt-params"><tr><th>name</th><th>as</th><th>required</th><th>tunnel</th><th>description</th></tr>
            <tr class="plentry ">
               <td class="pt ">code</td>
               <td class="pt ">undefined</td>
               <td class="pt ">false</td>
               <td class="pt ">no</td>
               <td class="pd ">Contains the element to be evaluted for documentation.</td>
            </tr>
            <tr class="plentry ">
               <td class="pt ">parentdoc</td>
               <td class="pt ">undefined</td>
               <td class="pt ">false</td>
               <td class="pt ">no</td>
               <td class="pd ">The p:documentation used to document the closest documented ancestor
      (used to make sure it isn't used twice).</td>
            </tr>
         </table>
      </section>
   <section class="section sourcecode">
      <header class="title sourcecode-header"><h1>Source Code</h1></header>
      <pre class="codeblock"><code class="">&lt;xsl:template xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:p="http://www.w3.org/ns/xproc" xmlns:xd="http://pipeline.daisy.org/ns/sample/doc" name="subdoc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="parentdoc"/&gt;

    &lt;xsl:if test="not(name($code) = 'p:documentation')"&gt;
      &lt;xsl:for-each select="$code/*"&gt;
        &lt;xsl:choose&gt;
          &lt;!-- Don't document the documentation ;) --&gt;
          &lt;xsl:when test="name(.) = 'p:documentation'"/&gt;

          &lt;!-- When the current element contains a p:documentation child targeting it, use it --&gt;
          &lt;xsl:when test="./p:documentation[@xd:target='parent'][1] and not(generate-id(./p:documentation[@xd:target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./p:documentation[@xd:target='parent'][1]"/&gt;
            &lt;xsl:call-template name="pipedoc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first child of the current element is a p:documentation and is not targeting another element, use it --&gt;
          &lt;xsl:when test="name(./*[1]) = 'p:documentation' and not(./*[1]/@xd:target = 'following') and not(generate-id(./*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./*[1]"/&gt;
            &lt;xsl:call-template name="pipedoc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first preceding sibling is a p:documentation and is not targeting another element, use it --&gt;
          &lt;xsl:when test="name(preceding-sibling::*[1]) = 'p:documentation' and not(preceding-sibling::*[1]/@xd:target = 'parent') and not(generate-id(preceding-sibling::*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="preceding-sibling::*[1]"/&gt;
            &lt;xsl:call-template name="pipedoc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- The element has no documentation, and it's not the root element so don't document it --&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:otherwise&gt;

        &lt;/xsl:choose&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;</code></pre>
   </section></section>
      <section class="reference XSLT "><header class="title "><h1>xsl:template - pipedoc</h1></header><p class="shortdesc ">Documents an element using its corresponding p:documentation element.</p><section class="abstract "><header class="abstract-header"><h1>Description</h1></header><p>
      
    
    This is where the main action happens. Relevant bits of information are retrieved and
      structured as DITA-XML.
    
    
  </p></section>
      <section class="section ">
         
      </section>
      <section class="section parameters xslt-params">
         <header class="title io-header"><h1>Parameters (xsl:param / xsl:with-param)</h1></header>
         <table class="parml xslt-params"><tr><th>name</th><th>as</th><th>required</th><th>tunnel</th><th>description</th></tr>
            <tr class="plentry ">
               <td class="pt ">code</td>
               <td class="pt ">undefined</td>
               <td class="pt ">false</td>
               <td class="pt ">no</td>
               <td class="pd ">Contains the XProc code to be documentated.</td>
            </tr>
            <tr class="plentry ">
               <td class="pt ">doc</td>
               <td class="pt ">undefined</td>
               <td class="pt ">false</td>
               <td class="pt ">no</td>
               <td class="pd ">Contains the p:documentation used as documentation.</td>
            </tr>
         </table>
      </section>
   <section class="section sourcecode">
      <header class="title sourcecode-header"><h1>Source Code</h1></header>
      <pre class="codeblock"><code class="">&lt;xsl:template xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:p="http://www.w3.org/ns/xproc" xmlns:xd="http://pipeline.daisy.org/ns/sample/doc" name="pipedoc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="doc" required="yes"/&gt;

    &lt;reference id="{generate-id($code)}"&gt;
      &lt;title&gt;
        &lt;xsl:value-of select="name($code)"/&gt;
        &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
        &lt;/xsl:if&gt;
      &lt;/title&gt;

      &lt;abstract&gt;
        &lt;shortdesc&gt;
          &lt;xsl:apply-templates select="$doc/xd:short"/&gt;
        &lt;/shortdesc&gt;
        &lt;xsl:apply-templates select="$doc/xd:detail"/&gt;
      &lt;/abstract&gt;

      &lt;prolog&gt;
        &lt;xsl:for-each select="$doc/xd:author | $doc/xd:contributor | $doc/xd:maintainer"&gt;
          &lt;author&gt;
            &lt;xsl:choose&gt;
              &lt;xsl:when test="local-name() = 'author'"&gt;
                &lt;xsl:attribute name="type"&gt;creator&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'contributor'"&gt;
                &lt;xsl:attribute name="type"&gt;contributor&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'maintainer'"&gt;
                &lt;xsl:attribute name="type"&gt;maintainer&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
            &lt;/xsl:choose&gt;
            &lt;xsl:apply-templates select="./xd:name"/&gt;
            &lt;xsl:if test="./xd:name and ./xd:mailto"&gt; (&lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./xd:mailto"/&gt;
            &lt;xsl:if test="./xd:name and ./xd:mailto"&gt;)&lt;/xsl:if&gt;
            &lt;xsl:if test="(./xd:name or ./xd:mailto) and ./xd:organization"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./xd:organization"/&gt;
          &lt;/author&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:for-each select="$doc/xd:copyright"&gt;
          &lt;copyright&gt;
            &lt;copyryear&gt;
              &lt;xsl:attribute name="year"&gt;
                &lt;xsl:apply-templates select="./xd:year"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/copyryear&gt;
            &lt;copyrholder&gt;
              &lt;xsl:apply-templates select="./xd:holder"/&gt;
            &lt;/copyrholder&gt;
          &lt;/copyright&gt;
        &lt;/xsl:for-each&gt;
        &lt;metadata&gt;
          &lt;audience type="programmer" job="programming" experiencelevel="expert"/&gt;
          &lt;othermeta name="programming-language" content="XProc"/&gt;
          &lt;xsl:for-each select="$doc/xd:version"&gt;
            &lt;othermeta name="version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;xsl:for-each select="$doc/xd:since"&gt;
            &lt;othermeta name="since"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;!--xsl:for-each select="$doc/xd:see"&gt;
            &lt;othermeta name="see"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each--&gt;
          &lt;xsl:for-each select="$doc/xd:deprecated"&gt;
            &lt;othermeta name="deprecated"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;

          &lt;!-- XProc version --&gt;
          &lt;xsl:if test="$code/@version or $code/@p:version"&gt;
            &lt;othermeta name="xproc-version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="$code/@version | $code/@p:version"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:if&gt;

          &lt;!-- XPath version --&gt;
          &lt;xsl:if test="$code/@xpath-version or $code/@p:xpath-version"&gt;
            &lt;othermeta name="xpath-version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="$code/@xpath-version | $code/@p:xpath-version"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:if&gt;
        &lt;/metadata&gt;
      &lt;/prolog&gt;

      &lt;refbody&gt;
        &lt;section&gt;
          &lt;apiname&gt;
            &lt;xsl:choose&gt;
              &lt;xsl:when test="$code/@name"&gt;
                &lt;xsl:value-of select="$code/@name"/&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:otherwise&gt;
                &lt;xsl:value-of select="name($code)"/&gt;
              &lt;/xsl:otherwise&gt;
            &lt;/xsl:choose&gt;
          &lt;/apiname&gt;
        &lt;/section&gt;
        &lt;xsl:if test="count($code/p:input)&amp;gt;0"&gt;
          &lt;section outputclass="parameters xproc-inputs"&gt;
            &lt;title outputclass="io-header"&gt;Inputs&lt;/title&gt;
            &lt;parml outputclass="xproc-inputs"&gt;
              &lt;xsl:choose&gt;
                &lt;xsl:when test="$code/p:input"&gt;
                  &lt;!--plentry&gt;
                  &lt;pt&gt;Name&lt;/pt&gt;
                  &lt;pt&gt;Primary&lt;/pt&gt;
                  &lt;pt&gt;Sequence&lt;/pt&gt;
                  &lt;pt&gt;Connection&lt;/pt&gt;
                  &lt;pd&gt;Description&lt;/pd&gt;
                &lt;/plentry--&gt;
                  &lt;xsl:for-each select="$code/p:input"&gt;
                    &lt;plentry&gt;
                      &lt;pt&gt;
                        &lt;xsl:value-of select="@port"/&gt;
                      &lt;/pt&gt;
                      &lt;pt&gt;
                        &lt;xsl:choose&gt;
                          &lt;xsl:when test="count($code/p:input) = 1 or @primary = 'true'"&gt;true&lt;/xsl:when&gt;
                          &lt;xsl:otherwise&gt;false&lt;/xsl:otherwise&gt;
                        &lt;/xsl:choose&gt;
                      &lt;/pt&gt;
                      &lt;pt&gt;
                        &lt;xsl:choose&gt;
                          &lt;xsl:when test="@sequence = 'true'"&gt;true&lt;/xsl:when&gt;
                          &lt;xsl:when test="@sequence = 'false'"&gt;false&lt;/xsl:when&gt;
                          &lt;xsl:otherwise/&gt;
                        &lt;/xsl:choose&gt;
                      &lt;/pt&gt;
                      &lt;pt&gt;
                        &lt;xsl:choose&gt;
                          &lt;xsl:when test="not(count(p:empty | p:inline | p:data | p:document | p:pipe) = 1)"/&gt;
                          &lt;xsl:when test="p:empty"&gt;empty&lt;/xsl:when&gt;
                          &lt;xsl:when test="p:inline"&gt;inline&lt;/xsl:when&gt;
                          &lt;xsl:when test="p:data"&gt;
                            &lt;xsl:value-of select="p:data/@href"/&gt;
                          &lt;/xsl:when&gt;
                          &lt;xsl:when test="p:document"&gt;
                            &lt;xsl:value-of select="p:document/@href"/&gt;
                          &lt;/xsl:when&gt;
                          &lt;xsl:when test="p:pipe"&gt;
                            &lt;xsl:value-of select="concat(p:pipe/@port,'@',p:pipe/@step)"/&gt;
                          &lt;/xsl:when&gt;
                        &lt;/xsl:choose&gt;
                      &lt;/pt&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="port" select="@port"/&gt;
                        &lt;xsl:apply-templates select="$doc/xd:input[@port=$port]"/&gt;
                      &lt;/pd&gt;
                    &lt;/plentry&gt;
                  &lt;/xsl:for-each&gt;
                &lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt;
                  &lt;plentry&gt;
                    &lt;pt/&gt;
                    &lt;pt/&gt;
                    &lt;pt/&gt;
                    &lt;pt&gt;Implicit&lt;/pt&gt;
                    &lt;pd&gt;
                      &lt;xsl:value-of select="$doc/xd:input"/&gt;
                    &lt;/pd&gt;
                  &lt;/plentry&gt;
                &lt;/xsl:otherwise&gt;
              &lt;/xsl:choose&gt;
            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;

        &lt;xsl:if test="count($code/p:output)&amp;gt;0"&gt;
          &lt;section outputclass="parameters xproc-outputs"&gt;
            &lt;title outputclass="io-header"&gt;Outputs&lt;/title&gt;
            &lt;parml outputclass="xproc-outputs"&gt;
              &lt;xsl:choose&gt;
                &lt;xsl:when test="$code/p:output"&gt;
                  &lt;!--plentry&gt;
                  &lt;pt&gt;Name&lt;/pt&gt;
                  &lt;pt&gt;Primary&lt;/pt&gt;
                  &lt;pt&gt;Sequence&lt;/pt&gt;
                  &lt;pt&gt;Connection&lt;/pt&gt;
                  &lt;pd&gt;Description&lt;/pd&gt;
                &lt;/plentry--&gt;
                  &lt;xsl:for-each select="$code/p:output"&gt;
                    &lt;plentry&gt;
                      &lt;pt&gt;
                        &lt;xsl:value-of select="@port"/&gt;
                      &lt;/pt&gt;
                      &lt;pt&gt;
                        &lt;xsl:choose&gt;
                          &lt;xsl:when test="count($code/p:output) = 1 or @primary = 'true'"&gt;true&lt;/xsl:when&gt;
                          &lt;xsl:otherwise&gt;false&lt;/xsl:otherwise&gt;
                        &lt;/xsl:choose&gt;
                      &lt;/pt&gt;
                      &lt;pt&gt;
                        &lt;xsl:choose&gt;
                          &lt;xsl:when test="@sequence = 'true'"&gt;true&lt;/xsl:when&gt;
                          &lt;xsl:when test="@sequence = 'false'"&gt;false&lt;/xsl:when&gt;
                          &lt;xsl:otherwise/&gt;
                        &lt;/xsl:choose&gt;
                      &lt;/pt&gt;
                      &lt;pt&gt;
                        &lt;xsl:choose&gt;
                          &lt;xsl:when test="not(count(p:empty | p:inline | p:data | p:document | p:pipe) = 1)"/&gt;
                          &lt;xsl:when test="p:empty"&gt;empty&lt;/xsl:when&gt;
                          &lt;xsl:when test="p:inline"&gt;inline&lt;/xsl:when&gt;
                          &lt;xsl:when test="p:data"&gt;
                            &lt;xsl:value-of select="p:data/@href"/&gt;
                          &lt;/xsl:when&gt;
                          &lt;xsl:when test="p:document"&gt;
                            &lt;xsl:value-of select="p:document/@href"/&gt;
                          &lt;/xsl:when&gt;
                          &lt;xsl:when test="p:pipe"&gt;
                            &lt;xsl:value-of select="concat(p:pipe/@port,'@',p:pipe/@step)"/&gt;
                          &lt;/xsl:when&gt;
                        &lt;/xsl:choose&gt;
                      &lt;/pt&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="port" select="@port"/&gt;
                        &lt;xsl:apply-templates select="$doc/xd:output[@port=$port]"/&gt;
                      &lt;/pd&gt;
                    &lt;/plentry&gt;
                  &lt;/xsl:for-each&gt;
                &lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt;
                  &lt;plentry&gt;
                    &lt;pt/&gt;
                    &lt;pt/&gt;
                    &lt;pt/&gt;
                    &lt;pt&gt;Implicit&lt;/pt&gt;
                    &lt;pd&gt;
                      &lt;xsl:value-of select="$doc/xd:output"/&gt;
                    &lt;/pd&gt;
                  &lt;/plentry&gt;
                &lt;/xsl:otherwise&gt;
              &lt;/xsl:choose&gt;
            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;

        &lt;xsl:if test="$code/p:option | $code/p:with-option"&gt;
          &lt;section outputclass="parameters xproc-options"&gt;
            &lt;title outputclass="io-header"&gt;Options&lt;/title&gt;
            &lt;parml outputclass="xproc-options"&gt;
              &lt;xsl:choose&gt;
                &lt;xsl:when test="count($code/p:with-option) &amp;gt; 0"&gt;
                  &lt;xsl:attribute name="outputclass" select="'xproc-options xproc-with-options'"/&gt;
                &lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt;
                  &lt;xsl:attribute name="outputclass" select="'xproc-options'"/&gt;
                &lt;/xsl:otherwise&gt;
              &lt;/xsl:choose&gt;
              &lt;!--plentry&gt;
                &lt;pt&gt;Name&lt;/pt&gt;
                &lt;pd&gt;Required&lt;/pd&gt;
                &lt;xsl:if test="count($code/p:with-option) &gt; 0"&gt;
                &lt;pd&gt;Connection&lt;/pd&gt;
                &lt;/xsl:if&gt;
                &lt;pd&gt;Description&lt;/pd&gt;
                &lt;/plentry--&gt;
              &lt;xsl:for-each select="$code/p:option | $code/p:with-option"&gt;
                &lt;plentry&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="@name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="name(.) = 'p:with-option' and not(@required)"/&gt;
                      &lt;xsl:when test="@required = 'false'"&gt;false&lt;/xsl:when&gt;
                      &lt;xsl:when test="@required = 'true'"&gt;true&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:if test="name(.) = 'p:with-option'"&gt;
                    &lt;pt&gt;
                      &lt;xsl:choose&gt;
                        &lt;xsl:when test="not(count(p:empty | p:inline | p:data | p:document | p:pipe) = 1)"/&gt;
                        &lt;xsl:when test="p:empty"&gt;empty&lt;/xsl:when&gt;
                        &lt;xsl:when test="p:inline"&gt;inline&lt;/xsl:when&gt;
                        &lt;xsl:when test="p:data"&gt;
                          &lt;xsl:value-of select="p:data/@href"/&gt;
                        &lt;/xsl:when&gt;
                        &lt;xsl:when test="p:document"&gt;
                          &lt;xsl:value-of select="p:document/@href"/&gt;
                        &lt;/xsl:when&gt;
                        &lt;xsl:when test="p:pipe"&gt;
                          &lt;xsl:value-of select="concat(p:pipe/@port,'@',p:pipe/@step)"/&gt;
                        &lt;/xsl:when&gt;
                      &lt;/xsl:choose&gt;
                    &lt;/pt&gt;
                  &lt;/xsl:if&gt;
                  &lt;pd&gt;
                    &lt;xsl:variable name="port" select="@port"/&gt;
                    &lt;xsl:apply-templates select="$doc/xd:option[@port=$port]"/&gt;
                  &lt;/pd&gt;
                &lt;/plentry&gt;
              &lt;/xsl:for-each&gt;
            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;

        &lt;xsl:if test="$code/p:with-param"&gt;
          &lt;section outputclass="parameters xproc-with-params"&gt;
            &lt;title outputclass="io-header"&gt;Parameters&lt;/title&gt;
            &lt;parml outputclass="xproc-with-params"&gt;
              &lt;xsl:attribute name="outputclass" select="'xproc-with-params'"/&gt;
              &lt;!--plentry&gt;
                &lt;pt&gt;Name&lt;/pt&gt;
                &lt;pd&gt;Required&lt;/pd&gt;
                &lt;xsl:if test="count($code/p:with-param) &gt; 0"&gt;
                &lt;pd&gt;Connection&lt;/pd&gt;
                &lt;/xsl:if&gt;
                &lt;pd&gt;Description&lt;/pd&gt;
                &lt;/plentry--&gt;
              &lt;xsl:for-each select="$code/p:with-param"&gt;
                &lt;plentry&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="@port"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="not(count(p:empty | p:inline | p:data | p:document | p:pipe) = 1)"/&gt;
                      &lt;xsl:when test="p:empty"&gt;empty&lt;/xsl:when&gt;
                      &lt;xsl:when test="p:inline"&gt;inline&lt;/xsl:when&gt;
                      &lt;xsl:when test="p:data"&gt;
                        &lt;xsl:value-of select="p:data/@href"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="p:document"&gt;
                        &lt;xsl:value-of select="p:document/@href"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="p:pipe"&gt;
                        &lt;xsl:value-of select="concat(p:pipe/@port,'@',p:pipe/@step)"/&gt;
                      &lt;/xsl:when&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pd&gt;
                    &lt;xsl:variable name="name" select="@name"/&gt;
                    &lt;xsl:apply-templates select="$doc/xd:param[@name=$name]"/&gt;
                  &lt;/pd&gt;
                &lt;/plentry&gt;
              &lt;/xsl:for-each&gt;
            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;

      &lt;/refbody&gt;

      &lt;xsl:if test="count($code//p:import) &amp;gt; 0 or count($code//p:document) &amp;gt; 0 or count($doc/xd:see) &amp;gt; 0"&gt;
        &lt;related-links&gt;
          &lt;xsl:if test="count($code//p:import) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (p:import)&lt;/title&gt;
              &lt;xsl:for-each select="$code//p:import"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the p:import statements from the XProc
                script.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($code//p:document) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (p:document)&lt;/title&gt;
              &lt;xsl:for-each select="$code//p:document"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from documents loaded with the p:document
                step in the XProc script.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($doc/xd:see) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;See also&lt;/title&gt;
              &lt;xsl:for-each select="$doc/xd:see"&gt;
                &lt;link href="{./text()}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These are related readings suggested by the author of the XProc
                script.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
        &lt;/related-links&gt;
      &lt;/xsl:if&gt;
      
      &lt;section outputclass="sourcecode"&gt;
        &lt;title outputclass="sourcecode-header"&gt;Source Code&lt;/title&gt;
        &lt;codeblock&gt;
          &lt;xsl:for-each select="$code"&gt;
            &lt;xsl:call-template name="xml-to-string"/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/codeblock&gt;
      &lt;/section&gt;
    &lt;/reference&gt;

  &lt;/xsl:template&gt;</code></pre>
   </section></section>
      <section class="reference XSLT "><header class="title "><h1>xsl:template</h1></header><p class="shortdesc ">&lt;xd:code/&gt; becomes &lt;codeblock outputclass="language-xslt"/&gt;</p><section class="section sourcecode">
      <header class="title sourcecode-header"><h1>Source Code</h1></header>
      <pre class="codeblock"><code class="">&lt;xsl:template xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:p="http://www.w3.org/ns/xproc" xmlns:xd="http://pipeline.daisy.org/ns/sample/doc" match="xd:code"&gt;
    &lt;codeblock outputclass="language-xslt"&gt;&lt;xsl:apply-templates/&gt;&lt;/codeblock&gt;
  &lt;/xsl:template&gt;</code></pre>
   </section></section>
   </section>
</html>