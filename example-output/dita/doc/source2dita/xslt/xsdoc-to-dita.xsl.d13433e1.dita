<reference id="d13433e1">
   <title>xsl:stylesheet</title>
   <abstract>
      <shortdesc>Transforms the input XSLT document to a DITA Reference Topic.</shortdesc>
   </abstract>
   <prolog>
      <author type="creator">Jostein Austvik Jacobsen, NLB, josteinaj@gmail.com</author>
      <copyright>
         <copyryear year="2010"/>
         <copyrholder/>
      </copyright>
      <metadata>
         <audience type="programmer" job="programming" experiencelevel="expert"/>
         <othermeta name="programming-language" content="XSLT"/>
         <othermeta name="version" content="0.1"/>
         <othermeta name="xslt-version" content="2.0"/>
         <othermeta name="xpath-version" content="2.0"/>
      </metadata>
   </prolog>
   <refbody>
      <section>
         <apiname>xsl:stylesheet</apiname>
      </section>
      <section outputclass="parameters xslt-outputs">
         <title outputclass="io-header">Outputs (xsl:output)</title>
         <parml outputclass="xslt-outputs">
            <pt/>
            <pt>xml</pt>
            <pt>yes</pt>
            <pt/>
            <pt/>
            <pt>yes</pt>
            <pt>UTF-8</pt>
            <pt>text/xml</pt>
            <pt>no</pt>
            <pt>omit</pt>
            <pt/>
            <pd/>
         </parml>
      </section>
   </refbody>
   <section outputclass="sourcecode">
      <title outputclass="sourcecode-header">Source Code</title>
      <codeblock>&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xd="http://pipeline.daisy.org/ns/sample/doc" xmlns:xsltdoc="http://www.pnp-software.com/XSLTdoc" exclude-result-prefixes="#all" version="2.0"&gt;

  &lt;xsl:output method="xml" indent="yes" encoding="UTF-8"/&gt;

  &lt;codeblock&gt;&lt;xsl:stylesheet exclude-result-prefixes="#all" version="2.0"&gt;

  &lt;xsl:output method="xml" indent="yes" encoding="UTF-8"/&gt;

  &lt;xd:doc target="parent"&gt;&lt;xd:short&gt;Transforms the input XSLT document to a DITA Reference Topic.&lt;/xd:short&gt;&lt;xd:author&gt;&lt;xd:name&gt;Jostein Austvik Jacobsen&lt;/xd:name&gt;&lt;xd:mailto&gt;josteinaj@gmail.com&lt;/xd:mailto&gt;&lt;xd:organization&gt;NLB&lt;/xd:organization&gt;&lt;/xd:author&gt;&lt;xd:copyright&gt;&lt;xd:year&gt;2010&lt;/xd:year&gt;&lt;/xd:copyright&gt;&lt;xd:version&gt;0.1&lt;/xd:version&gt;&lt;/xd:doc&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Override the "/" template in xml-to-string.xsl.&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Identity template.&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="@*|node()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Main template&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    Creates the top element &amp;lt;dita&amp;gt;, determines how to document the XSLT stylesheet
      itself, and recurses throught the code looking for xd:doc elements.
  &lt;/xd:detail&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="/*"&gt;
    &lt;dita&gt;
      &lt;xsl:choose&gt;

        &lt;!-- When the root element contains a xd:doc child targeting it, use it --&gt;
        &lt;xsl:when test="./xsltdoc:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- Same as above, but in the XSLTdoc namespace --&gt;
        &lt;xsl:when test="./xd:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xd:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- When the first child of the root element is a xd:doc and is not targeting another element, use it --&gt;
        &lt;xsl:when test="(name(./*[1])='xsltdoc:doc' or name(./*[1])='xd:doc') and not(./*[1]/@target='following')"&gt;
          &lt;xsl:variable name="parentdoc" select="./*[1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- The root element is not documented. Create some empty documentation for it. --&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc"&gt;
              &lt;xsl:element name="xd:doc"/&gt;
            &lt;/xsl:with-param&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:otherwise&gt;

      &lt;/xsl:choose&gt;
    &lt;/dita&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Recursive template that looks for xd:doc elements.&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    If there is a xd:doc belonging to the current element; document the current element
      using it. At the same time; recurse further through the script looking for more elements to be
      documented.
    
    
  &lt;/xd:detail&gt;&lt;xd:param name="code"&gt;Contains the element to be evaluted for documentation.&lt;/xd:param&gt;&lt;xd:param name="parentdoc"&gt;The xd:doc used to document the closest documented ancestor (used to
      make sure it isn't used twice).&lt;/xd:param&gt;&lt;/xd:doc&gt;
  &lt;xsl:template name="subdoc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="parentdoc"&gt;
      &lt;xsl:element name="xd:doc"/&gt;
    &lt;/xsl:param&gt;

    &lt;xsl:if test="not(name($code) = 'xd:doc' or name($code) = 'xsltdoc:doc')"&gt;
      &lt;xsl:for-each select="$code/*"&gt;
        &lt;xsl:choose&gt;
          &lt;!-- Don't document the documentation ;) --&gt;
          &lt;xsl:when test="name(.) = 'xd:doc' or name(.) = 'xsltdoc:doc'"/&gt;

          &lt;!-- When the current element contains a xd:doc child targeting it, use it --&gt;
          &lt;xsl:when test="./xd:doc[@target='parent'][1] and not(generate-id(./xd:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xd:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the current element contains a xs:doc child targeting it, use it --&gt;
          &lt;xsl:when test="(./xsltdoc:doc[@target='parent'][1]) and not(generate-id(./xsltdoc:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first child of the current element is a xd:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(./*[1]) = 'xd:doc' or name(./*[1]) = 'xsltdoc:doc') and not(./*[1]/@target = 'following') and not(generate-id(./*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first preceding sibling is a xs:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(preceding-sibling::*[1]) = 'xd:doc' or name(preceding-sibling::*[1]) = 'xsltdoc:doc') and not(preceding-sibling::*[1]/@target = 'parent') and not(generate-id(preceding-sibling::*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="preceding-sibling::*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- The element has no documentation, and it's not the root element so don't document it --&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:otherwise&gt;

        &lt;/xsl:choose&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Documents an element using its corresponding xd:doc element.&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    This is where the main action happens. Relevant bits of information are retrieved and
      structured as DITA-XML.
    
    
  &lt;/xd:detail&gt;&lt;xd:param name="code"&gt;Contains the XSLT code to be documentated.&lt;/xd:param&gt;&lt;xd:param name="doc"&gt;Contains the xd:doc used as documentation.&lt;/xd:param&gt;&lt;/xd:doc&gt;
  &lt;xsl:template name="doc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="doc" required="yes"/&gt;

    &lt;reference id="{generate-id($code)}"&gt;
      &lt;title&gt;
        &lt;xsl:value-of select="name($code)"/&gt;
        &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
        &lt;/xsl:if&gt;
      &lt;/title&gt;

      &lt;abstract&gt;
        &lt;shortdesc&gt;
          &lt;xsl:apply-templates select="$doc/*[local-name()='short']/node()"/&gt;
        &lt;/shortdesc&gt;
        &lt;xsl:apply-templates select="$doc/*[local-name()='detail']/node()"/&gt;
      &lt;/abstract&gt;

      &lt;prolog&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='author'] | $doc/*[local-name()='contributor'] | $doc/*[local-name()='maintainer']"&gt;
          &lt;author&gt;
            &lt;xsl:choose&gt;
              &lt;xsl:when test="local-name() = 'author'"&gt;
                &lt;xsl:attribute name="type"&gt;creator&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'contributor'"&gt;
                &lt;xsl:attribute name="type"&gt;contributor&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'maintainer'"&gt;
                &lt;xsl:attribute name="type"&gt;maintainer&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
            &lt;/xsl:choose&gt;
            &lt;xsl:apply-templates select="./*[local-name()='name']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='name'] and (./*[local-name()='organization'] or ./*[local-name()='mailto'])"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='organization']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='organization'] and ./*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='mailto']/node()"/&gt;
          &lt;/author&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='copyright']"&gt;

          &lt;xsl:choose&gt;
            &lt;xsl:when test="count($doc/xd:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyryear&gt;
                  &lt;xsl:attribute name="year"&gt;
                    &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='year']/node()"/&gt;
                  &lt;/xsl:attribute&gt;
                &lt;/copyryear&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="$doc/xd:copyright/*[local-name()='holder']"&gt;
                      &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='holder']/node()"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                      &lt;xsl:if test="$doc/xd:copyright/*[local-name()='name']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='name']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization' or local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='organization']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='mailto']/node()"/&gt;
                      &lt;/xsl:if&gt;
                    &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:when test="count($doc/xsltdoc:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:apply-templates select="$doc/xsltdoc:copyright/node()"/&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
          &lt;/xsl:choose&gt;
        &lt;/xsl:for-each&gt;
        &lt;metadata&gt;
          &lt;audience type="programmer" job="programming" experiencelevel="expert"/&gt;
          &lt;othermeta name="programming-language" content="XSLT"/&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='version']"&gt;
            &lt;othermeta name="version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='since']"&gt;
            &lt;othermeta name="since"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;!--xsl:for-each select="$doc/*[local-name()='see']"&gt;
            &lt;othermeta name="see"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each--&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='deprecated']"&gt;
            &lt;othermeta name="deprecated"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;

          &lt;!-- XSLT and XPath version --&gt;
          &lt;xsl:if test="name($code)='xsl:stylesheet' or name($code)='xsl:transform'"&gt;
            &lt;xsl:variable name="xslt-version" select="$code/@version | $code/@xsl:version"/&gt;
            &lt;othermeta name="xslt-version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="$xslt-version"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
            &lt;xsl:if test="$xslt-version='1.0' or $xslt-version='2.0'"&gt;
              &lt;othermeta name="xpath-version"&gt;
                &lt;xsl:attribute name="content"&gt;
                  &lt;xsl:value-of select="$xslt-version"/&gt;
                &lt;/xsl:attribute&gt;
              &lt;/othermeta&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:if&gt;

        &lt;/metadata&gt;
      &lt;/prolog&gt;

      &lt;refbody&gt;
        &lt;section&gt;
          &lt;apiname&gt;
            &lt;xsl:value-of select="name($code)"/&gt;
            &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
            &lt;/xsl:if&gt;
          &lt;/apiname&gt;
        &lt;/section&gt;

        &lt;xsl:if test="$code/xsl:param | $code/xsl:with-param"&gt;
          &lt;section outputclass="parameters xslt-params"&gt;
            &lt;title outputclass="io-header"&gt;Parameters (xsl:param / xsl:with-param)&lt;/title&gt;
            &lt;parml outputclass="xslt-params"&gt;
              &lt;xsl:choose&gt;
                &lt;xsl:when test="count($code/xsl:with-param) &amp;gt; 0"&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params xslt-with-params'"/&gt;
                &lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params'"/&gt;
                &lt;/xsl:otherwise&gt;
              &lt;/xsl:choose&gt;
              &lt;!--plentry&gt;
                &lt;pt&gt;Name&lt;/pt&gt;
                &lt;pd&gt;As&lt;/pd&gt;
                &lt;xsl:if test="count($code/xsl:with-param) &gt; 0"&gt;
                  &lt;pd&gt;Required&lt;/pd&gt;
                &lt;/xsl:if&gt;
                &lt;pd&gt;Tunnel&lt;/pd&gt;
                &lt;pd&gt;Description&lt;/pd&gt;
              &lt;/plentry--&gt;
              &lt;xsl:for-each select="$code/xsl:param | $code/xsl:with-param"&gt;
                &lt;xsl:variable name="name" select="@name"/&gt;
                &lt;plentry&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@as"&gt;
                        &lt;xsl:value-of select="@as"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;undefined&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:if test="name(.) = 'xsl:param'"&gt;
                    &lt;pt&gt;
                      &lt;xsl:choose&gt;
                        &lt;xsl:when test="name(./parent::*) = 'xsl:function' or @required = 'true'"&gt;true&lt;/xsl:when&gt;
                        &lt;xsl:otherwise&gt;false&lt;/xsl:otherwise&gt;
                      &lt;/xsl:choose&gt;
                    &lt;/pt&gt;
                  &lt;/xsl:if&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@tunnel='yes'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="name(.)='xsl:param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="name(.)='xsl:with-param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='with-param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                  &lt;/xsl:choose&gt;
                &lt;/plentry&gt;
              &lt;/xsl:for-each&gt;
            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;

        &lt;xsl:if test="name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform'"&gt;
          &lt;section outputclass="parameters xslt-outputs"&gt;
            &lt;title outputclass="io-header"&gt;Outputs (xsl:output)&lt;/title&gt;
            &lt;parml outputclass="xslt-outputs"&gt;
              &lt;xsl:attribute name="outputclass" select="'xslt-outputs'"/&gt;
              &lt;!--
              name
              method
              indent
              doctype-system
              doctype-public
              include-content-type
              encoding
              media-type
              omit-xml-declaration
              standalone
              version
              comments
              --&gt;
              &lt;pt/&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@method"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@method[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@indent"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@indent[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-system"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-system[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-public"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-public[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@include-content-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@include-content-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@encoding"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@encoding[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;UTF-8/UTF-16&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@media-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@media-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@omit-xml-declaration"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@omit-xml-declaration[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@standalone"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@standalone[last()] or 'omit'"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@version"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@version[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pd&gt;
                &lt;xsl:apply-templates select="$doc/*[local-name()='output' and not(@name)]/node()"/&gt;
              &lt;/pd&gt;
              &lt;xsl:for-each select="$code/xsl:output[@name]"&gt;
                &lt;xsl:if test="not(@name=preceding::xsl:output/@name)"&gt;
                  &lt;xsl:variable name="name" select="@name"/&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@method[last()] or 'undefined'"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@indent"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@indent[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-system"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-system[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-public"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-public[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@include-content-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@include-content-type[last()] or 'yes'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@encoding"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@encoding[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;UTF&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@media-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@media-type[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@omit-xml-declaration"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@omit-xml-declaration[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@standalone"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@standalone[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@version"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@version[last()] or 'undefined'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pd&gt;
                    &lt;xsl:apply-templates select="$doc/*[local-name()='output' and @name=$name]/node()"/&gt;
                  &lt;/pd&gt;
                &lt;/xsl:if&gt;
              &lt;/xsl:for-each&gt;

            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;
      &lt;/refbody&gt;

      &lt;xsl:if test="(name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform') and (count($code//xsl:include) &amp;gt; 0 or count($code//xsl:import) &amp;gt; 0 or count($doc/*[local-name()='see']) &amp;gt; 0)"&gt;
        &lt;related-links&gt;
          &lt;xsl:if test="count($code//xsl:include) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:include)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:include"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:include statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($code//xsl:import) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:import)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:import"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:import statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($doc/*[local-name()='see']) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;See also&lt;/title&gt;
              &lt;xsl:for-each select="$doc/*[local-name()='see']"&gt;
                &lt;link href="{./text()}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These are related readings suggested by the author of the XSLT
                stylesheet.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
        &lt;/related-links&gt;
      &lt;/xsl:if&gt;

      &lt;section outputclass="sourcecode"&gt;
        &lt;title outputclass="sourcecode-header"&gt;Source Code&lt;/title&gt;
        &lt;codeblock&gt;
          &lt;xsl:copy-of select="$code"/&gt;
          &lt;!--xsl:for-each select="$code"&gt;
            &lt;xsl:if test="not(self::xd:doc) and not(self::xsltdoc:doc)"&gt;
              &lt;xsl:call-template name="xml-to-string"/&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:for-each--&gt;
        &lt;/codeblock&gt;
      &lt;/section&gt;
    &lt;/reference&gt;

  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;&amp;lt;xd:code/&amp;gt; becomes &amp;lt;codeblock outputclass="language-xslt"/&amp;gt;&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="xd:code"&gt;
    &lt;codeblock outputclass="language-xslt"&gt;&lt;xsl:apply-templates/&gt;&lt;/codeblock&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;&lt;/codeblock&gt;

  &lt;codeblock&gt;&lt;xsl:stylesheet exclude-result-prefixes="#all" version="2.0"&gt;

  &lt;xsl:output method="xml" indent="yes" encoding="UTF-8"/&gt;

  &lt;xd:doc target="parent"&gt;&lt;xd:short&gt;Transforms the input XSLT document to a DITA Reference Topic.&lt;/xd:short&gt;&lt;xd:author&gt;&lt;xd:name&gt;Jostein Austvik Jacobsen&lt;/xd:name&gt;&lt;xd:mailto&gt;josteinaj@gmail.com&lt;/xd:mailto&gt;&lt;xd:organization&gt;NLB&lt;/xd:organization&gt;&lt;/xd:author&gt;&lt;xd:copyright&gt;&lt;xd:year&gt;2010&lt;/xd:year&gt;&lt;/xd:copyright&gt;&lt;xd:version&gt;0.1&lt;/xd:version&gt;&lt;/xd:doc&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Override the "/" template in xml-to-string.xsl.&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Identity template.&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="@*|node()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Main template&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    Creates the top element &amp;lt;dita&amp;gt;, determines how to document the XSLT stylesheet
      itself, and recurses throught the code looking for xd:doc elements.
  &lt;/xd:detail&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="/*"&gt;
    &lt;dita&gt;
      &lt;xsl:choose&gt;

        &lt;!-- When the root element contains a xd:doc child targeting it, use it --&gt;
        &lt;xsl:when test="./xsltdoc:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- Same as above, but in the XSLTdoc namespace --&gt;
        &lt;xsl:when test="./xd:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xd:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- When the first child of the root element is a xd:doc and is not targeting another element, use it --&gt;
        &lt;xsl:when test="(name(./*[1])='xsltdoc:doc' or name(./*[1])='xd:doc') and not(./*[1]/@target='following')"&gt;
          &lt;xsl:variable name="parentdoc" select="./*[1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- The root element is not documented. Create some empty documentation for it. --&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc"&gt;
              &lt;xsl:element name="xd:doc"/&gt;
            &lt;/xsl:with-param&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:otherwise&gt;

      &lt;/xsl:choose&gt;
    &lt;/dita&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Recursive template that looks for xd:doc elements.&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    If there is a xd:doc belonging to the current element; document the current element
      using it. At the same time; recurse further through the script looking for more elements to be
      documented.
    
    
  &lt;/xd:detail&gt;&lt;xd:param name="code"&gt;Contains the element to be evaluted for documentation.&lt;/xd:param&gt;&lt;xd:param name="parentdoc"&gt;The xd:doc used to document the closest documented ancestor (used to
      make sure it isn't used twice).&lt;/xd:param&gt;&lt;/xd:doc&gt;
  &lt;xsl:template name="subdoc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="parentdoc"&gt;
      &lt;xsl:element name="xd:doc"/&gt;
    &lt;/xsl:param&gt;

    &lt;xsl:if test="not(name($code) = 'xd:doc' or name($code) = 'xsltdoc:doc')"&gt;
      &lt;xsl:for-each select="$code/*"&gt;
        &lt;xsl:choose&gt;
          &lt;!-- Don't document the documentation ;) --&gt;
          &lt;xsl:when test="name(.) = 'xd:doc' or name(.) = 'xsltdoc:doc'"/&gt;

          &lt;!-- When the current element contains a xd:doc child targeting it, use it --&gt;
          &lt;xsl:when test="./xd:doc[@target='parent'][1] and not(generate-id(./xd:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xd:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the current element contains a xs:doc child targeting it, use it --&gt;
          &lt;xsl:when test="(./xsltdoc:doc[@target='parent'][1]) and not(generate-id(./xsltdoc:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first child of the current element is a xd:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(./*[1]) = 'xd:doc' or name(./*[1]) = 'xsltdoc:doc') and not(./*[1]/@target = 'following') and not(generate-id(./*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first preceding sibling is a xs:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(preceding-sibling::*[1]) = 'xd:doc' or name(preceding-sibling::*[1]) = 'xsltdoc:doc') and not(preceding-sibling::*[1]/@target = 'parent') and not(generate-id(preceding-sibling::*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="preceding-sibling::*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- The element has no documentation, and it's not the root element so don't document it --&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:otherwise&gt;

        &lt;/xsl:choose&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Documents an element using its corresponding xd:doc element.&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    This is where the main action happens. Relevant bits of information are retrieved and
      structured as DITA-XML.
    
    
  &lt;/xd:detail&gt;&lt;xd:param name="code"&gt;Contains the XSLT code to be documentated.&lt;/xd:param&gt;&lt;xd:param name="doc"&gt;Contains the xd:doc used as documentation.&lt;/xd:param&gt;&lt;/xd:doc&gt;
  &lt;xsl:template name="doc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="doc" required="yes"/&gt;

    &lt;reference id="{generate-id($code)}"&gt;
      &lt;title&gt;
        &lt;xsl:value-of select="name($code)"/&gt;
        &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
        &lt;/xsl:if&gt;
      &lt;/title&gt;

      &lt;abstract&gt;
        &lt;shortdesc&gt;
          &lt;xsl:apply-templates select="$doc/*[local-name()='short']/node()"/&gt;
        &lt;/shortdesc&gt;
        &lt;xsl:apply-templates select="$doc/*[local-name()='detail']/node()"/&gt;
      &lt;/abstract&gt;

      &lt;prolog&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='author'] | $doc/*[local-name()='contributor'] | $doc/*[local-name()='maintainer']"&gt;
          &lt;author&gt;
            &lt;xsl:choose&gt;
              &lt;xsl:when test="local-name() = 'author'"&gt;
                &lt;xsl:attribute name="type"&gt;creator&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'contributor'"&gt;
                &lt;xsl:attribute name="type"&gt;contributor&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'maintainer'"&gt;
                &lt;xsl:attribute name="type"&gt;maintainer&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
            &lt;/xsl:choose&gt;
            &lt;xsl:apply-templates select="./*[local-name()='name']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='name'] and (./*[local-name()='organization'] or ./*[local-name()='mailto'])"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='organization']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='organization'] and ./*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='mailto']/node()"/&gt;
          &lt;/author&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='copyright']"&gt;

          &lt;xsl:choose&gt;
            &lt;xsl:when test="count($doc/xd:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyryear&gt;
                  &lt;xsl:attribute name="year"&gt;
                    &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='year']/node()"/&gt;
                  &lt;/xsl:attribute&gt;
                &lt;/copyryear&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="$doc/xd:copyright/*[local-name()='holder']"&gt;
                      &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='holder']/node()"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                      &lt;xsl:if test="$doc/xd:copyright/*[local-name()='name']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='name']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization' or local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='organization']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='mailto']/node()"/&gt;
                      &lt;/xsl:if&gt;
                    &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:when test="count($doc/xsltdoc:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:apply-templates select="$doc/xsltdoc:copyright/node()"/&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
          &lt;/xsl:choose&gt;
        &lt;/xsl:for-each&gt;
        &lt;metadata&gt;
          &lt;audience type="programmer" job="programming" experiencelevel="expert"/&gt;
          &lt;othermeta name="programming-language" content="XSLT"/&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='version']"&gt;
            &lt;othermeta name="version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='since']"&gt;
            &lt;othermeta name="since"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;!--xsl:for-each select="$doc/*[local-name()='see']"&gt;
            &lt;othermeta name="see"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each--&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='deprecated']"&gt;
            &lt;othermeta name="deprecated"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;

          &lt;!-- XSLT and XPath version --&gt;
          &lt;xsl:if test="name($code)='xsl:stylesheet' or name($code)='xsl:transform'"&gt;
            &lt;xsl:variable name="xslt-version" select="$code/@version | $code/@xsl:version"/&gt;
            &lt;othermeta name="xslt-version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="$xslt-version"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
            &lt;xsl:if test="$xslt-version='1.0' or $xslt-version='2.0'"&gt;
              &lt;othermeta name="xpath-version"&gt;
                &lt;xsl:attribute name="content"&gt;
                  &lt;xsl:value-of select="$xslt-version"/&gt;
                &lt;/xsl:attribute&gt;
              &lt;/othermeta&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:if&gt;

        &lt;/metadata&gt;
      &lt;/prolog&gt;

      &lt;refbody&gt;
        &lt;section&gt;
          &lt;apiname&gt;
            &lt;xsl:value-of select="name($code)"/&gt;
            &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
            &lt;/xsl:if&gt;
          &lt;/apiname&gt;
        &lt;/section&gt;

        &lt;xsl:if test="$code/xsl:param | $code/xsl:with-param"&gt;
          &lt;section outputclass="parameters xslt-params"&gt;
            &lt;title outputclass="io-header"&gt;Parameters (xsl:param / xsl:with-param)&lt;/title&gt;
            &lt;parml outputclass="xslt-params"&gt;
              &lt;xsl:choose&gt;
                &lt;xsl:when test="count($code/xsl:with-param) &amp;gt; 0"&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params xslt-with-params'"/&gt;
                &lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params'"/&gt;
                &lt;/xsl:otherwise&gt;
              &lt;/xsl:choose&gt;
              &lt;!--plentry&gt;
                &lt;pt&gt;Name&lt;/pt&gt;
                &lt;pd&gt;As&lt;/pd&gt;
                &lt;xsl:if test="count($code/xsl:with-param) &gt; 0"&gt;
                  &lt;pd&gt;Required&lt;/pd&gt;
                &lt;/xsl:if&gt;
                &lt;pd&gt;Tunnel&lt;/pd&gt;
                &lt;pd&gt;Description&lt;/pd&gt;
              &lt;/plentry--&gt;
              &lt;xsl:for-each select="$code/xsl:param | $code/xsl:with-param"&gt;
                &lt;xsl:variable name="name" select="@name"/&gt;
                &lt;plentry&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@as"&gt;
                        &lt;xsl:value-of select="@as"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;undefined&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:if test="name(.) = 'xsl:param'"&gt;
                    &lt;pt&gt;
                      &lt;xsl:choose&gt;
                        &lt;xsl:when test="name(./parent::*) = 'xsl:function' or @required = 'true'"&gt;true&lt;/xsl:when&gt;
                        &lt;xsl:otherwise&gt;false&lt;/xsl:otherwise&gt;
                      &lt;/xsl:choose&gt;
                    &lt;/pt&gt;
                  &lt;/xsl:if&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@tunnel='yes'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="name(.)='xsl:param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="name(.)='xsl:with-param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='with-param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                  &lt;/xsl:choose&gt;
                &lt;/plentry&gt;
              &lt;/xsl:for-each&gt;
            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;

        &lt;xsl:if test="name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform'"&gt;
          &lt;section outputclass="parameters xslt-outputs"&gt;
            &lt;title outputclass="io-header"&gt;Outputs (xsl:output)&lt;/title&gt;
            &lt;parml outputclass="xslt-outputs"&gt;
              &lt;xsl:attribute name="outputclass" select="'xslt-outputs'"/&gt;
              &lt;!--
              name
              method
              indent
              doctype-system
              doctype-public
              include-content-type
              encoding
              media-type
              omit-xml-declaration
              standalone
              version
              comments
              --&gt;
              &lt;pt/&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@method"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@method[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@indent"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@indent[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-system"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-system[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-public"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-public[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@include-content-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@include-content-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@encoding"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@encoding[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;UTF-8/UTF-16&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@media-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@media-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@omit-xml-declaration"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@omit-xml-declaration[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@standalone"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@standalone[last()] or 'omit'"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@version"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@version[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pd&gt;
                &lt;xsl:apply-templates select="$doc/*[local-name()='output' and not(@name)]/node()"/&gt;
              &lt;/pd&gt;
              &lt;xsl:for-each select="$code/xsl:output[@name]"&gt;
                &lt;xsl:if test="not(@name=preceding::xsl:output/@name)"&gt;
                  &lt;xsl:variable name="name" select="@name"/&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@method[last()] or 'undefined'"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@indent"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@indent[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-system"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-system[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-public"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-public[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@include-content-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@include-content-type[last()] or 'yes'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@encoding"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@encoding[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;UTF&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@media-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@media-type[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@omit-xml-declaration"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@omit-xml-declaration[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@standalone"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@standalone[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@version"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@version[last()] or 'undefined'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pd&gt;
                    &lt;xsl:apply-templates select="$doc/*[local-name()='output' and @name=$name]/node()"/&gt;
                  &lt;/pd&gt;
                &lt;/xsl:if&gt;
              &lt;/xsl:for-each&gt;

            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;
      &lt;/refbody&gt;

      &lt;xsl:if test="(name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform') and (count($code//xsl:include) &amp;gt; 0 or count($code//xsl:import) &amp;gt; 0 or count($doc/*[local-name()='see']) &amp;gt; 0)"&gt;
        &lt;related-links&gt;
          &lt;xsl:if test="count($code//xsl:include) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:include)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:include"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:include statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($code//xsl:import) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:import)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:import"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:import statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($doc/*[local-name()='see']) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;See also&lt;/title&gt;
              &lt;xsl:for-each select="$doc/*[local-name()='see']"&gt;
                &lt;link href="{./text()}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These are related readings suggested by the author of the XSLT
                stylesheet.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
        &lt;/related-links&gt;
      &lt;/xsl:if&gt;

      &lt;section outputclass="sourcecode"&gt;
        &lt;title outputclass="sourcecode-header"&gt;Source Code&lt;/title&gt;
        &lt;codeblock&gt;
          &lt;xsl:copy-of select="$code"/&gt;
          &lt;!--xsl:for-each select="$code"&gt;
            &lt;xsl:if test="not(self::xd:doc) and not(self::xsltdoc:doc)"&gt;
              &lt;xsl:call-template name="xml-to-string"/&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:for-each--&gt;
        &lt;/codeblock&gt;
      &lt;/section&gt;
    &lt;/reference&gt;

  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;&amp;lt;xd:code/&amp;gt; becomes &amp;lt;codeblock outputclass="language-xslt"/&amp;gt;&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="xd:code"&gt;
    &lt;codeblock outputclass="language-xslt"&gt;&lt;xsl:apply-templates/&gt;&lt;/codeblock&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;&lt;/codeblock&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;codeblock&gt;&lt;xsl:stylesheet exclude-result-prefixes="#all" version="2.0"&gt;

  &lt;xsl:output method="xml" indent="yes" encoding="UTF-8"/&gt;

  &lt;xd:doc target="parent"&gt;&lt;xd:short&gt;Transforms the input XSLT document to a DITA Reference Topic.&lt;/xd:short&gt;&lt;xd:author&gt;&lt;xd:name&gt;Jostein Austvik Jacobsen&lt;/xd:name&gt;&lt;xd:mailto&gt;josteinaj@gmail.com&lt;/xd:mailto&gt;&lt;xd:organization&gt;NLB&lt;/xd:organization&gt;&lt;/xd:author&gt;&lt;xd:copyright&gt;&lt;xd:year&gt;2010&lt;/xd:year&gt;&lt;/xd:copyright&gt;&lt;xd:version&gt;0.1&lt;/xd:version&gt;&lt;/xd:doc&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Override the "/" template in xml-to-string.xsl.&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Identity template.&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="@*|node()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Main template&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    Creates the top element &amp;lt;dita&amp;gt;, determines how to document the XSLT stylesheet
      itself, and recurses throught the code looking for xd:doc elements.
  &lt;/xd:detail&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="/*"&gt;
    &lt;dita&gt;
      &lt;xsl:choose&gt;

        &lt;!-- When the root element contains a xd:doc child targeting it, use it --&gt;
        &lt;xsl:when test="./xsltdoc:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- Same as above, but in the XSLTdoc namespace --&gt;
        &lt;xsl:when test="./xd:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xd:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- When the first child of the root element is a xd:doc and is not targeting another element, use it --&gt;
        &lt;xsl:when test="(name(./*[1])='xsltdoc:doc' or name(./*[1])='xd:doc') and not(./*[1]/@target='following')"&gt;
          &lt;xsl:variable name="parentdoc" select="./*[1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- The root element is not documented. Create some empty documentation for it. --&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc"&gt;
              &lt;xsl:element name="xd:doc"/&gt;
            &lt;/xsl:with-param&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:otherwise&gt;

      &lt;/xsl:choose&gt;
    &lt;/dita&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Recursive template that looks for xd:doc elements.&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    If there is a xd:doc belonging to the current element; document the current element
      using it. At the same time; recurse further through the script looking for more elements to be
      documented.
    
    
  &lt;/xd:detail&gt;&lt;xd:param name="code"&gt;Contains the element to be evaluted for documentation.&lt;/xd:param&gt;&lt;xd:param name="parentdoc"&gt;The xd:doc used to document the closest documented ancestor (used to
      make sure it isn't used twice).&lt;/xd:param&gt;&lt;/xd:doc&gt;
  &lt;xsl:template name="subdoc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="parentdoc"&gt;
      &lt;xsl:element name="xd:doc"/&gt;
    &lt;/xsl:param&gt;

    &lt;xsl:if test="not(name($code) = 'xd:doc' or name($code) = 'xsltdoc:doc')"&gt;
      &lt;xsl:for-each select="$code/*"&gt;
        &lt;xsl:choose&gt;
          &lt;!-- Don't document the documentation ;) --&gt;
          &lt;xsl:when test="name(.) = 'xd:doc' or name(.) = 'xsltdoc:doc'"/&gt;

          &lt;!-- When the current element contains a xd:doc child targeting it, use it --&gt;
          &lt;xsl:when test="./xd:doc[@target='parent'][1] and not(generate-id(./xd:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xd:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the current element contains a xs:doc child targeting it, use it --&gt;
          &lt;xsl:when test="(./xsltdoc:doc[@target='parent'][1]) and not(generate-id(./xsltdoc:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first child of the current element is a xd:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(./*[1]) = 'xd:doc' or name(./*[1]) = 'xsltdoc:doc') and not(./*[1]/@target = 'following') and not(generate-id(./*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first preceding sibling is a xs:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(preceding-sibling::*[1]) = 'xd:doc' or name(preceding-sibling::*[1]) = 'xsltdoc:doc') and not(preceding-sibling::*[1]/@target = 'parent') and not(generate-id(preceding-sibling::*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="preceding-sibling::*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- The element has no documentation, and it's not the root element so don't document it --&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:otherwise&gt;

        &lt;/xsl:choose&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Documents an element using its corresponding xd:doc element.&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    This is where the main action happens. Relevant bits of information are retrieved and
      structured as DITA-XML.
    
    
  &lt;/xd:detail&gt;&lt;xd:param name="code"&gt;Contains the XSLT code to be documentated.&lt;/xd:param&gt;&lt;xd:param name="doc"&gt;Contains the xd:doc used as documentation.&lt;/xd:param&gt;&lt;/xd:doc&gt;
  &lt;xsl:template name="doc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="doc" required="yes"/&gt;

    &lt;reference id="{generate-id($code)}"&gt;
      &lt;title&gt;
        &lt;xsl:value-of select="name($code)"/&gt;
        &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
        &lt;/xsl:if&gt;
      &lt;/title&gt;

      &lt;abstract&gt;
        &lt;shortdesc&gt;
          &lt;xsl:apply-templates select="$doc/*[local-name()='short']/node()"/&gt;
        &lt;/shortdesc&gt;
        &lt;xsl:apply-templates select="$doc/*[local-name()='detail']/node()"/&gt;
      &lt;/abstract&gt;

      &lt;prolog&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='author'] | $doc/*[local-name()='contributor'] | $doc/*[local-name()='maintainer']"&gt;
          &lt;author&gt;
            &lt;xsl:choose&gt;
              &lt;xsl:when test="local-name() = 'author'"&gt;
                &lt;xsl:attribute name="type"&gt;creator&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'contributor'"&gt;
                &lt;xsl:attribute name="type"&gt;contributor&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'maintainer'"&gt;
                &lt;xsl:attribute name="type"&gt;maintainer&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
            &lt;/xsl:choose&gt;
            &lt;xsl:apply-templates select="./*[local-name()='name']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='name'] and (./*[local-name()='organization'] or ./*[local-name()='mailto'])"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='organization']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='organization'] and ./*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='mailto']/node()"/&gt;
          &lt;/author&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='copyright']"&gt;

          &lt;xsl:choose&gt;
            &lt;xsl:when test="count($doc/xd:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyryear&gt;
                  &lt;xsl:attribute name="year"&gt;
                    &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='year']/node()"/&gt;
                  &lt;/xsl:attribute&gt;
                &lt;/copyryear&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="$doc/xd:copyright/*[local-name()='holder']"&gt;
                      &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='holder']/node()"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                      &lt;xsl:if test="$doc/xd:copyright/*[local-name()='name']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='name']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization' or local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='organization']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='mailto']/node()"/&gt;
                      &lt;/xsl:if&gt;
                    &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:when test="count($doc/xsltdoc:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:apply-templates select="$doc/xsltdoc:copyright/node()"/&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
          &lt;/xsl:choose&gt;
        &lt;/xsl:for-each&gt;
        &lt;metadata&gt;
          &lt;audience type="programmer" job="programming" experiencelevel="expert"/&gt;
          &lt;othermeta name="programming-language" content="XSLT"/&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='version']"&gt;
            &lt;othermeta name="version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='since']"&gt;
            &lt;othermeta name="since"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;!--xsl:for-each select="$doc/*[local-name()='see']"&gt;
            &lt;othermeta name="see"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each--&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='deprecated']"&gt;
            &lt;othermeta name="deprecated"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;

          &lt;!-- XSLT and XPath version --&gt;
          &lt;xsl:if test="name($code)='xsl:stylesheet' or name($code)='xsl:transform'"&gt;
            &lt;xsl:variable name="xslt-version" select="$code/@version | $code/@xsl:version"/&gt;
            &lt;othermeta name="xslt-version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="$xslt-version"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
            &lt;xsl:if test="$xslt-version='1.0' or $xslt-version='2.0'"&gt;
              &lt;othermeta name="xpath-version"&gt;
                &lt;xsl:attribute name="content"&gt;
                  &lt;xsl:value-of select="$xslt-version"/&gt;
                &lt;/xsl:attribute&gt;
              &lt;/othermeta&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:if&gt;

        &lt;/metadata&gt;
      &lt;/prolog&gt;

      &lt;refbody&gt;
        &lt;section&gt;
          &lt;apiname&gt;
            &lt;xsl:value-of select="name($code)"/&gt;
            &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
            &lt;/xsl:if&gt;
          &lt;/apiname&gt;
        &lt;/section&gt;

        &lt;xsl:if test="$code/xsl:param | $code/xsl:with-param"&gt;
          &lt;section outputclass="parameters xslt-params"&gt;
            &lt;title outputclass="io-header"&gt;Parameters (xsl:param / xsl:with-param)&lt;/title&gt;
            &lt;parml outputclass="xslt-params"&gt;
              &lt;xsl:choose&gt;
                &lt;xsl:when test="count($code/xsl:with-param) &amp;gt; 0"&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params xslt-with-params'"/&gt;
                &lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params'"/&gt;
                &lt;/xsl:otherwise&gt;
              &lt;/xsl:choose&gt;
              &lt;!--plentry&gt;
                &lt;pt&gt;Name&lt;/pt&gt;
                &lt;pd&gt;As&lt;/pd&gt;
                &lt;xsl:if test="count($code/xsl:with-param) &gt; 0"&gt;
                  &lt;pd&gt;Required&lt;/pd&gt;
                &lt;/xsl:if&gt;
                &lt;pd&gt;Tunnel&lt;/pd&gt;
                &lt;pd&gt;Description&lt;/pd&gt;
              &lt;/plentry--&gt;
              &lt;xsl:for-each select="$code/xsl:param | $code/xsl:with-param"&gt;
                &lt;xsl:variable name="name" select="@name"/&gt;
                &lt;plentry&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@as"&gt;
                        &lt;xsl:value-of select="@as"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;undefined&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:if test="name(.) = 'xsl:param'"&gt;
                    &lt;pt&gt;
                      &lt;xsl:choose&gt;
                        &lt;xsl:when test="name(./parent::*) = 'xsl:function' or @required = 'true'"&gt;true&lt;/xsl:when&gt;
                        &lt;xsl:otherwise&gt;false&lt;/xsl:otherwise&gt;
                      &lt;/xsl:choose&gt;
                    &lt;/pt&gt;
                  &lt;/xsl:if&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@tunnel='yes'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="name(.)='xsl:param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="name(.)='xsl:with-param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='with-param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                  &lt;/xsl:choose&gt;
                &lt;/plentry&gt;
              &lt;/xsl:for-each&gt;
            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;

        &lt;xsl:if test="name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform'"&gt;
          &lt;section outputclass="parameters xslt-outputs"&gt;
            &lt;title outputclass="io-header"&gt;Outputs (xsl:output)&lt;/title&gt;
            &lt;parml outputclass="xslt-outputs"&gt;
              &lt;xsl:attribute name="outputclass" select="'xslt-outputs'"/&gt;
              &lt;!--
              name
              method
              indent
              doctype-system
              doctype-public
              include-content-type
              encoding
              media-type
              omit-xml-declaration
              standalone
              version
              comments
              --&gt;
              &lt;pt/&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@method"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@method[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@indent"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@indent[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-system"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-system[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-public"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-public[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@include-content-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@include-content-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@encoding"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@encoding[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;UTF-8/UTF-16&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@media-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@media-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@omit-xml-declaration"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@omit-xml-declaration[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@standalone"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@standalone[last()] or 'omit'"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@version"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@version[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pd&gt;
                &lt;xsl:apply-templates select="$doc/*[local-name()='output' and not(@name)]/node()"/&gt;
              &lt;/pd&gt;
              &lt;xsl:for-each select="$code/xsl:output[@name]"&gt;
                &lt;xsl:if test="not(@name=preceding::xsl:output/@name)"&gt;
                  &lt;xsl:variable name="name" select="@name"/&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@method[last()] or 'undefined'"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@indent"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@indent[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-system"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-system[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-public"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-public[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@include-content-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@include-content-type[last()] or 'yes'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@encoding"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@encoding[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;UTF&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@media-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@media-type[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@omit-xml-declaration"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@omit-xml-declaration[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@standalone"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@standalone[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@version"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@version[last()] or 'undefined'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pd&gt;
                    &lt;xsl:apply-templates select="$doc/*[local-name()='output' and @name=$name]/node()"/&gt;
                  &lt;/pd&gt;
                &lt;/xsl:if&gt;
              &lt;/xsl:for-each&gt;

            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;
      &lt;/refbody&gt;

      &lt;xsl:if test="(name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform') and (count($code//xsl:include) &amp;gt; 0 or count($code//xsl:import) &amp;gt; 0 or count($doc/*[local-name()='see']) &amp;gt; 0)"&gt;
        &lt;related-links&gt;
          &lt;xsl:if test="count($code//xsl:include) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:include)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:include"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:include statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($code//xsl:import) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:import)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:import"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:import statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($doc/*[local-name()='see']) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;See also&lt;/title&gt;
              &lt;xsl:for-each select="$doc/*[local-name()='see']"&gt;
                &lt;link href="{./text()}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These are related readings suggested by the author of the XSLT
                stylesheet.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
        &lt;/related-links&gt;
      &lt;/xsl:if&gt;

      &lt;section outputclass="sourcecode"&gt;
        &lt;title outputclass="sourcecode-header"&gt;Source Code&lt;/title&gt;
        &lt;codeblock&gt;
          &lt;xsl:copy-of select="$code"/&gt;
          &lt;!--xsl:for-each select="$code"&gt;
            &lt;xsl:if test="not(self::xd:doc) and not(self::xsltdoc:doc)"&gt;
              &lt;xsl:call-template name="xml-to-string"/&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:for-each--&gt;
        &lt;/codeblock&gt;
      &lt;/section&gt;
    &lt;/reference&gt;

  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;&amp;lt;xd:code/&amp;gt; becomes &amp;lt;codeblock outputclass="language-xslt"/&amp;gt;&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="xd:code"&gt;
    &lt;codeblock outputclass="language-xslt"&gt;&lt;xsl:apply-templates/&gt;&lt;/codeblock&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;&lt;/codeblock&gt;
  &lt;xsl:template match="@*|node()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;

  &lt;codeblock&gt;&lt;xsl:stylesheet exclude-result-prefixes="#all" version="2.0"&gt;

  &lt;xsl:output method="xml" indent="yes" encoding="UTF-8"/&gt;

  &lt;xd:doc target="parent"&gt;&lt;xd:short&gt;Transforms the input XSLT document to a DITA Reference Topic.&lt;/xd:short&gt;&lt;xd:author&gt;&lt;xd:name&gt;Jostein Austvik Jacobsen&lt;/xd:name&gt;&lt;xd:mailto&gt;josteinaj@gmail.com&lt;/xd:mailto&gt;&lt;xd:organization&gt;NLB&lt;/xd:organization&gt;&lt;/xd:author&gt;&lt;xd:copyright&gt;&lt;xd:year&gt;2010&lt;/xd:year&gt;&lt;/xd:copyright&gt;&lt;xd:version&gt;0.1&lt;/xd:version&gt;&lt;/xd:doc&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Override the "/" template in xml-to-string.xsl.&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Identity template.&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="@*|node()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Main template&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    Creates the top element &amp;lt;dita&amp;gt;, determines how to document the XSLT stylesheet
      itself, and recurses throught the code looking for xd:doc elements.
  &lt;/xd:detail&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="/*"&gt;
    &lt;dita&gt;
      &lt;xsl:choose&gt;

        &lt;!-- When the root element contains a xd:doc child targeting it, use it --&gt;
        &lt;xsl:when test="./xsltdoc:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- Same as above, but in the XSLTdoc namespace --&gt;
        &lt;xsl:when test="./xd:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xd:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- When the first child of the root element is a xd:doc and is not targeting another element, use it --&gt;
        &lt;xsl:when test="(name(./*[1])='xsltdoc:doc' or name(./*[1])='xd:doc') and not(./*[1]/@target='following')"&gt;
          &lt;xsl:variable name="parentdoc" select="./*[1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- The root element is not documented. Create some empty documentation for it. --&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc"&gt;
              &lt;xsl:element name="xd:doc"/&gt;
            &lt;/xsl:with-param&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:otherwise&gt;

      &lt;/xsl:choose&gt;
    &lt;/dita&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Recursive template that looks for xd:doc elements.&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    If there is a xd:doc belonging to the current element; document the current element
      using it. At the same time; recurse further through the script looking for more elements to be
      documented.
    
    
  &lt;/xd:detail&gt;&lt;xd:param name="code"&gt;Contains the element to be evaluted for documentation.&lt;/xd:param&gt;&lt;xd:param name="parentdoc"&gt;The xd:doc used to document the closest documented ancestor (used to
      make sure it isn't used twice).&lt;/xd:param&gt;&lt;/xd:doc&gt;
  &lt;xsl:template name="subdoc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="parentdoc"&gt;
      &lt;xsl:element name="xd:doc"/&gt;
    &lt;/xsl:param&gt;

    &lt;xsl:if test="not(name($code) = 'xd:doc' or name($code) = 'xsltdoc:doc')"&gt;
      &lt;xsl:for-each select="$code/*"&gt;
        &lt;xsl:choose&gt;
          &lt;!-- Don't document the documentation ;) --&gt;
          &lt;xsl:when test="name(.) = 'xd:doc' or name(.) = 'xsltdoc:doc'"/&gt;

          &lt;!-- When the current element contains a xd:doc child targeting it, use it --&gt;
          &lt;xsl:when test="./xd:doc[@target='parent'][1] and not(generate-id(./xd:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xd:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the current element contains a xs:doc child targeting it, use it --&gt;
          &lt;xsl:when test="(./xsltdoc:doc[@target='parent'][1]) and not(generate-id(./xsltdoc:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first child of the current element is a xd:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(./*[1]) = 'xd:doc' or name(./*[1]) = 'xsltdoc:doc') and not(./*[1]/@target = 'following') and not(generate-id(./*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first preceding sibling is a xs:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(preceding-sibling::*[1]) = 'xd:doc' or name(preceding-sibling::*[1]) = 'xsltdoc:doc') and not(preceding-sibling::*[1]/@target = 'parent') and not(generate-id(preceding-sibling::*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="preceding-sibling::*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- The element has no documentation, and it's not the root element so don't document it --&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:otherwise&gt;

        &lt;/xsl:choose&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Documents an element using its corresponding xd:doc element.&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    This is where the main action happens. Relevant bits of information are retrieved and
      structured as DITA-XML.
    
    
  &lt;/xd:detail&gt;&lt;xd:param name="code"&gt;Contains the XSLT code to be documentated.&lt;/xd:param&gt;&lt;xd:param name="doc"&gt;Contains the xd:doc used as documentation.&lt;/xd:param&gt;&lt;/xd:doc&gt;
  &lt;xsl:template name="doc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="doc" required="yes"/&gt;

    &lt;reference id="{generate-id($code)}"&gt;
      &lt;title&gt;
        &lt;xsl:value-of select="name($code)"/&gt;
        &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
        &lt;/xsl:if&gt;
      &lt;/title&gt;

      &lt;abstract&gt;
        &lt;shortdesc&gt;
          &lt;xsl:apply-templates select="$doc/*[local-name()='short']/node()"/&gt;
        &lt;/shortdesc&gt;
        &lt;xsl:apply-templates select="$doc/*[local-name()='detail']/node()"/&gt;
      &lt;/abstract&gt;

      &lt;prolog&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='author'] | $doc/*[local-name()='contributor'] | $doc/*[local-name()='maintainer']"&gt;
          &lt;author&gt;
            &lt;xsl:choose&gt;
              &lt;xsl:when test="local-name() = 'author'"&gt;
                &lt;xsl:attribute name="type"&gt;creator&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'contributor'"&gt;
                &lt;xsl:attribute name="type"&gt;contributor&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'maintainer'"&gt;
                &lt;xsl:attribute name="type"&gt;maintainer&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
            &lt;/xsl:choose&gt;
            &lt;xsl:apply-templates select="./*[local-name()='name']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='name'] and (./*[local-name()='organization'] or ./*[local-name()='mailto'])"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='organization']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='organization'] and ./*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='mailto']/node()"/&gt;
          &lt;/author&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='copyright']"&gt;

          &lt;xsl:choose&gt;
            &lt;xsl:when test="count($doc/xd:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyryear&gt;
                  &lt;xsl:attribute name="year"&gt;
                    &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='year']/node()"/&gt;
                  &lt;/xsl:attribute&gt;
                &lt;/copyryear&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="$doc/xd:copyright/*[local-name()='holder']"&gt;
                      &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='holder']/node()"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                      &lt;xsl:if test="$doc/xd:copyright/*[local-name()='name']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='name']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization' or local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='organization']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='mailto']/node()"/&gt;
                      &lt;/xsl:if&gt;
                    &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:when test="count($doc/xsltdoc:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:apply-templates select="$doc/xsltdoc:copyright/node()"/&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
          &lt;/xsl:choose&gt;
        &lt;/xsl:for-each&gt;
        &lt;metadata&gt;
          &lt;audience type="programmer" job="programming" experiencelevel="expert"/&gt;
          &lt;othermeta name="programming-language" content="XSLT"/&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='version']"&gt;
            &lt;othermeta name="version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='since']"&gt;
            &lt;othermeta name="since"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;!--xsl:for-each select="$doc/*[local-name()='see']"&gt;
            &lt;othermeta name="see"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each--&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='deprecated']"&gt;
            &lt;othermeta name="deprecated"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;

          &lt;!-- XSLT and XPath version --&gt;
          &lt;xsl:if test="name($code)='xsl:stylesheet' or name($code)='xsl:transform'"&gt;
            &lt;xsl:variable name="xslt-version" select="$code/@version | $code/@xsl:version"/&gt;
            &lt;othermeta name="xslt-version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="$xslt-version"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
            &lt;xsl:if test="$xslt-version='1.0' or $xslt-version='2.0'"&gt;
              &lt;othermeta name="xpath-version"&gt;
                &lt;xsl:attribute name="content"&gt;
                  &lt;xsl:value-of select="$xslt-version"/&gt;
                &lt;/xsl:attribute&gt;
              &lt;/othermeta&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:if&gt;

        &lt;/metadata&gt;
      &lt;/prolog&gt;

      &lt;refbody&gt;
        &lt;section&gt;
          &lt;apiname&gt;
            &lt;xsl:value-of select="name($code)"/&gt;
            &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
            &lt;/xsl:if&gt;
          &lt;/apiname&gt;
        &lt;/section&gt;

        &lt;xsl:if test="$code/xsl:param | $code/xsl:with-param"&gt;
          &lt;section outputclass="parameters xslt-params"&gt;
            &lt;title outputclass="io-header"&gt;Parameters (xsl:param / xsl:with-param)&lt;/title&gt;
            &lt;parml outputclass="xslt-params"&gt;
              &lt;xsl:choose&gt;
                &lt;xsl:when test="count($code/xsl:with-param) &amp;gt; 0"&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params xslt-with-params'"/&gt;
                &lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params'"/&gt;
                &lt;/xsl:otherwise&gt;
              &lt;/xsl:choose&gt;
              &lt;!--plentry&gt;
                &lt;pt&gt;Name&lt;/pt&gt;
                &lt;pd&gt;As&lt;/pd&gt;
                &lt;xsl:if test="count($code/xsl:with-param) &gt; 0"&gt;
                  &lt;pd&gt;Required&lt;/pd&gt;
                &lt;/xsl:if&gt;
                &lt;pd&gt;Tunnel&lt;/pd&gt;
                &lt;pd&gt;Description&lt;/pd&gt;
              &lt;/plentry--&gt;
              &lt;xsl:for-each select="$code/xsl:param | $code/xsl:with-param"&gt;
                &lt;xsl:variable name="name" select="@name"/&gt;
                &lt;plentry&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@as"&gt;
                        &lt;xsl:value-of select="@as"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;undefined&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:if test="name(.) = 'xsl:param'"&gt;
                    &lt;pt&gt;
                      &lt;xsl:choose&gt;
                        &lt;xsl:when test="name(./parent::*) = 'xsl:function' or @required = 'true'"&gt;true&lt;/xsl:when&gt;
                        &lt;xsl:otherwise&gt;false&lt;/xsl:otherwise&gt;
                      &lt;/xsl:choose&gt;
                    &lt;/pt&gt;
                  &lt;/xsl:if&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@tunnel='yes'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="name(.)='xsl:param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="name(.)='xsl:with-param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='with-param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                  &lt;/xsl:choose&gt;
                &lt;/plentry&gt;
              &lt;/xsl:for-each&gt;
            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;

        &lt;xsl:if test="name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform'"&gt;
          &lt;section outputclass="parameters xslt-outputs"&gt;
            &lt;title outputclass="io-header"&gt;Outputs (xsl:output)&lt;/title&gt;
            &lt;parml outputclass="xslt-outputs"&gt;
              &lt;xsl:attribute name="outputclass" select="'xslt-outputs'"/&gt;
              &lt;!--
              name
              method
              indent
              doctype-system
              doctype-public
              include-content-type
              encoding
              media-type
              omit-xml-declaration
              standalone
              version
              comments
              --&gt;
              &lt;pt/&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@method"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@method[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@indent"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@indent[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-system"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-system[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-public"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-public[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@include-content-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@include-content-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@encoding"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@encoding[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;UTF-8/UTF-16&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@media-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@media-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@omit-xml-declaration"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@omit-xml-declaration[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@standalone"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@standalone[last()] or 'omit'"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@version"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@version[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pd&gt;
                &lt;xsl:apply-templates select="$doc/*[local-name()='output' and not(@name)]/node()"/&gt;
              &lt;/pd&gt;
              &lt;xsl:for-each select="$code/xsl:output[@name]"&gt;
                &lt;xsl:if test="not(@name=preceding::xsl:output/@name)"&gt;
                  &lt;xsl:variable name="name" select="@name"/&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@method[last()] or 'undefined'"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@indent"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@indent[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-system"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-system[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-public"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-public[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@include-content-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@include-content-type[last()] or 'yes'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@encoding"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@encoding[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;UTF&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@media-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@media-type[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@omit-xml-declaration"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@omit-xml-declaration[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@standalone"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@standalone[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@version"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@version[last()] or 'undefined'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pd&gt;
                    &lt;xsl:apply-templates select="$doc/*[local-name()='output' and @name=$name]/node()"/&gt;
                  &lt;/pd&gt;
                &lt;/xsl:if&gt;
              &lt;/xsl:for-each&gt;

            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;
      &lt;/refbody&gt;

      &lt;xsl:if test="(name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform') and (count($code//xsl:include) &amp;gt; 0 or count($code//xsl:import) &amp;gt; 0 or count($doc/*[local-name()='see']) &amp;gt; 0)"&gt;
        &lt;related-links&gt;
          &lt;xsl:if test="count($code//xsl:include) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:include)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:include"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:include statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($code//xsl:import) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:import)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:import"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:import statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($doc/*[local-name()='see']) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;See also&lt;/title&gt;
              &lt;xsl:for-each select="$doc/*[local-name()='see']"&gt;
                &lt;link href="{./text()}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These are related readings suggested by the author of the XSLT
                stylesheet.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
        &lt;/related-links&gt;
      &lt;/xsl:if&gt;

      &lt;section outputclass="sourcecode"&gt;
        &lt;title outputclass="sourcecode-header"&gt;Source Code&lt;/title&gt;
        &lt;codeblock&gt;
          &lt;xsl:copy-of select="$code"/&gt;
          &lt;!--xsl:for-each select="$code"&gt;
            &lt;xsl:if test="not(self::xd:doc) and not(self::xsltdoc:doc)"&gt;
              &lt;xsl:call-template name="xml-to-string"/&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:for-each--&gt;
        &lt;/codeblock&gt;
      &lt;/section&gt;
    &lt;/reference&gt;

  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;&amp;lt;xd:code/&amp;gt; becomes &amp;lt;codeblock outputclass="language-xslt"/&amp;gt;&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="xd:code"&gt;
    &lt;codeblock outputclass="language-xslt"&gt;&lt;xsl:apply-templates/&gt;&lt;/codeblock&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;&lt;/codeblock&gt;
  &lt;xsl:template match="/*"&gt;
    &lt;dita&gt;
      &lt;xsl:choose&gt;

        &lt;!-- When the root element contains a xd:doc child targeting it, use it --&gt;
        &lt;xsl:when test="./xsltdoc:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- Same as above, but in the XSLTdoc namespace --&gt;
        &lt;xsl:when test="./xd:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xd:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- When the first child of the root element is a xd:doc and is not targeting another element, use it --&gt;
        &lt;xsl:when test="(name(./*[1])='xsltdoc:doc' or name(./*[1])='xd:doc') and not(./*[1]/@target='following')"&gt;
          &lt;xsl:variable name="parentdoc" select="./*[1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- The root element is not documented. Create some empty documentation for it. --&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc"&gt;
              &lt;xsl:element name="xd:doc"/&gt;
            &lt;/xsl:with-param&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:otherwise&gt;

      &lt;/xsl:choose&gt;
    &lt;/dita&gt;
  &lt;/xsl:template&gt;

  &lt;codeblock&gt;&lt;xsl:stylesheet exclude-result-prefixes="#all" version="2.0"&gt;

  &lt;xsl:output method="xml" indent="yes" encoding="UTF-8"/&gt;

  &lt;xd:doc target="parent"&gt;&lt;xd:short&gt;Transforms the input XSLT document to a DITA Reference Topic.&lt;/xd:short&gt;&lt;xd:author&gt;&lt;xd:name&gt;Jostein Austvik Jacobsen&lt;/xd:name&gt;&lt;xd:mailto&gt;josteinaj@gmail.com&lt;/xd:mailto&gt;&lt;xd:organization&gt;NLB&lt;/xd:organization&gt;&lt;/xd:author&gt;&lt;xd:copyright&gt;&lt;xd:year&gt;2010&lt;/xd:year&gt;&lt;/xd:copyright&gt;&lt;xd:version&gt;0.1&lt;/xd:version&gt;&lt;/xd:doc&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Override the "/" template in xml-to-string.xsl.&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Identity template.&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="@*|node()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Main template&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    Creates the top element &amp;lt;dita&amp;gt;, determines how to document the XSLT stylesheet
      itself, and recurses throught the code looking for xd:doc elements.
  &lt;/xd:detail&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="/*"&gt;
    &lt;dita&gt;
      &lt;xsl:choose&gt;

        &lt;!-- When the root element contains a xd:doc child targeting it, use it --&gt;
        &lt;xsl:when test="./xsltdoc:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- Same as above, but in the XSLTdoc namespace --&gt;
        &lt;xsl:when test="./xd:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xd:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- When the first child of the root element is a xd:doc and is not targeting another element, use it --&gt;
        &lt;xsl:when test="(name(./*[1])='xsltdoc:doc' or name(./*[1])='xd:doc') and not(./*[1]/@target='following')"&gt;
          &lt;xsl:variable name="parentdoc" select="./*[1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- The root element is not documented. Create some empty documentation for it. --&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc"&gt;
              &lt;xsl:element name="xd:doc"/&gt;
            &lt;/xsl:with-param&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:otherwise&gt;

      &lt;/xsl:choose&gt;
    &lt;/dita&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Recursive template that looks for xd:doc elements.&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    If there is a xd:doc belonging to the current element; document the current element
      using it. At the same time; recurse further through the script looking for more elements to be
      documented.
    
    
  &lt;/xd:detail&gt;&lt;xd:param name="code"&gt;Contains the element to be evaluted for documentation.&lt;/xd:param&gt;&lt;xd:param name="parentdoc"&gt;The xd:doc used to document the closest documented ancestor (used to
      make sure it isn't used twice).&lt;/xd:param&gt;&lt;/xd:doc&gt;
  &lt;xsl:template name="subdoc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="parentdoc"&gt;
      &lt;xsl:element name="xd:doc"/&gt;
    &lt;/xsl:param&gt;

    &lt;xsl:if test="not(name($code) = 'xd:doc' or name($code) = 'xsltdoc:doc')"&gt;
      &lt;xsl:for-each select="$code/*"&gt;
        &lt;xsl:choose&gt;
          &lt;!-- Don't document the documentation ;) --&gt;
          &lt;xsl:when test="name(.) = 'xd:doc' or name(.) = 'xsltdoc:doc'"/&gt;

          &lt;!-- When the current element contains a xd:doc child targeting it, use it --&gt;
          &lt;xsl:when test="./xd:doc[@target='parent'][1] and not(generate-id(./xd:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xd:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the current element contains a xs:doc child targeting it, use it --&gt;
          &lt;xsl:when test="(./xsltdoc:doc[@target='parent'][1]) and not(generate-id(./xsltdoc:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first child of the current element is a xd:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(./*[1]) = 'xd:doc' or name(./*[1]) = 'xsltdoc:doc') and not(./*[1]/@target = 'following') and not(generate-id(./*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first preceding sibling is a xs:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(preceding-sibling::*[1]) = 'xd:doc' or name(preceding-sibling::*[1]) = 'xsltdoc:doc') and not(preceding-sibling::*[1]/@target = 'parent') and not(generate-id(preceding-sibling::*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="preceding-sibling::*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- The element has no documentation, and it's not the root element so don't document it --&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:otherwise&gt;

        &lt;/xsl:choose&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Documents an element using its corresponding xd:doc element.&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    This is where the main action happens. Relevant bits of information are retrieved and
      structured as DITA-XML.
    
    
  &lt;/xd:detail&gt;&lt;xd:param name="code"&gt;Contains the XSLT code to be documentated.&lt;/xd:param&gt;&lt;xd:param name="doc"&gt;Contains the xd:doc used as documentation.&lt;/xd:param&gt;&lt;/xd:doc&gt;
  &lt;xsl:template name="doc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="doc" required="yes"/&gt;

    &lt;reference id="{generate-id($code)}"&gt;
      &lt;title&gt;
        &lt;xsl:value-of select="name($code)"/&gt;
        &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
        &lt;/xsl:if&gt;
      &lt;/title&gt;

      &lt;abstract&gt;
        &lt;shortdesc&gt;
          &lt;xsl:apply-templates select="$doc/*[local-name()='short']/node()"/&gt;
        &lt;/shortdesc&gt;
        &lt;xsl:apply-templates select="$doc/*[local-name()='detail']/node()"/&gt;
      &lt;/abstract&gt;

      &lt;prolog&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='author'] | $doc/*[local-name()='contributor'] | $doc/*[local-name()='maintainer']"&gt;
          &lt;author&gt;
            &lt;xsl:choose&gt;
              &lt;xsl:when test="local-name() = 'author'"&gt;
                &lt;xsl:attribute name="type"&gt;creator&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'contributor'"&gt;
                &lt;xsl:attribute name="type"&gt;contributor&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'maintainer'"&gt;
                &lt;xsl:attribute name="type"&gt;maintainer&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
            &lt;/xsl:choose&gt;
            &lt;xsl:apply-templates select="./*[local-name()='name']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='name'] and (./*[local-name()='organization'] or ./*[local-name()='mailto'])"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='organization']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='organization'] and ./*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='mailto']/node()"/&gt;
          &lt;/author&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='copyright']"&gt;

          &lt;xsl:choose&gt;
            &lt;xsl:when test="count($doc/xd:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyryear&gt;
                  &lt;xsl:attribute name="year"&gt;
                    &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='year']/node()"/&gt;
                  &lt;/xsl:attribute&gt;
                &lt;/copyryear&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="$doc/xd:copyright/*[local-name()='holder']"&gt;
                      &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='holder']/node()"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                      &lt;xsl:if test="$doc/xd:copyright/*[local-name()='name']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='name']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization' or local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='organization']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='mailto']/node()"/&gt;
                      &lt;/xsl:if&gt;
                    &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:when test="count($doc/xsltdoc:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:apply-templates select="$doc/xsltdoc:copyright/node()"/&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
          &lt;/xsl:choose&gt;
        &lt;/xsl:for-each&gt;
        &lt;metadata&gt;
          &lt;audience type="programmer" job="programming" experiencelevel="expert"/&gt;
          &lt;othermeta name="programming-language" content="XSLT"/&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='version']"&gt;
            &lt;othermeta name="version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='since']"&gt;
            &lt;othermeta name="since"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;!--xsl:for-each select="$doc/*[local-name()='see']"&gt;
            &lt;othermeta name="see"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each--&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='deprecated']"&gt;
            &lt;othermeta name="deprecated"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;

          &lt;!-- XSLT and XPath version --&gt;
          &lt;xsl:if test="name($code)='xsl:stylesheet' or name($code)='xsl:transform'"&gt;
            &lt;xsl:variable name="xslt-version" select="$code/@version | $code/@xsl:version"/&gt;
            &lt;othermeta name="xslt-version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="$xslt-version"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
            &lt;xsl:if test="$xslt-version='1.0' or $xslt-version='2.0'"&gt;
              &lt;othermeta name="xpath-version"&gt;
                &lt;xsl:attribute name="content"&gt;
                  &lt;xsl:value-of select="$xslt-version"/&gt;
                &lt;/xsl:attribute&gt;
              &lt;/othermeta&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:if&gt;

        &lt;/metadata&gt;
      &lt;/prolog&gt;

      &lt;refbody&gt;
        &lt;section&gt;
          &lt;apiname&gt;
            &lt;xsl:value-of select="name($code)"/&gt;
            &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
            &lt;/xsl:if&gt;
          &lt;/apiname&gt;
        &lt;/section&gt;

        &lt;xsl:if test="$code/xsl:param | $code/xsl:with-param"&gt;
          &lt;section outputclass="parameters xslt-params"&gt;
            &lt;title outputclass="io-header"&gt;Parameters (xsl:param / xsl:with-param)&lt;/title&gt;
            &lt;parml outputclass="xslt-params"&gt;
              &lt;xsl:choose&gt;
                &lt;xsl:when test="count($code/xsl:with-param) &amp;gt; 0"&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params xslt-with-params'"/&gt;
                &lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params'"/&gt;
                &lt;/xsl:otherwise&gt;
              &lt;/xsl:choose&gt;
              &lt;!--plentry&gt;
                &lt;pt&gt;Name&lt;/pt&gt;
                &lt;pd&gt;As&lt;/pd&gt;
                &lt;xsl:if test="count($code/xsl:with-param) &gt; 0"&gt;
                  &lt;pd&gt;Required&lt;/pd&gt;
                &lt;/xsl:if&gt;
                &lt;pd&gt;Tunnel&lt;/pd&gt;
                &lt;pd&gt;Description&lt;/pd&gt;
              &lt;/plentry--&gt;
              &lt;xsl:for-each select="$code/xsl:param | $code/xsl:with-param"&gt;
                &lt;xsl:variable name="name" select="@name"/&gt;
                &lt;plentry&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@as"&gt;
                        &lt;xsl:value-of select="@as"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;undefined&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:if test="name(.) = 'xsl:param'"&gt;
                    &lt;pt&gt;
                      &lt;xsl:choose&gt;
                        &lt;xsl:when test="name(./parent::*) = 'xsl:function' or @required = 'true'"&gt;true&lt;/xsl:when&gt;
                        &lt;xsl:otherwise&gt;false&lt;/xsl:otherwise&gt;
                      &lt;/xsl:choose&gt;
                    &lt;/pt&gt;
                  &lt;/xsl:if&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@tunnel='yes'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="name(.)='xsl:param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="name(.)='xsl:with-param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='with-param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                  &lt;/xsl:choose&gt;
                &lt;/plentry&gt;
              &lt;/xsl:for-each&gt;
            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;

        &lt;xsl:if test="name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform'"&gt;
          &lt;section outputclass="parameters xslt-outputs"&gt;
            &lt;title outputclass="io-header"&gt;Outputs (xsl:output)&lt;/title&gt;
            &lt;parml outputclass="xslt-outputs"&gt;
              &lt;xsl:attribute name="outputclass" select="'xslt-outputs'"/&gt;
              &lt;!--
              name
              method
              indent
              doctype-system
              doctype-public
              include-content-type
              encoding
              media-type
              omit-xml-declaration
              standalone
              version
              comments
              --&gt;
              &lt;pt/&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@method"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@method[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@indent"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@indent[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-system"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-system[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-public"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-public[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@include-content-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@include-content-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@encoding"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@encoding[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;UTF-8/UTF-16&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@media-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@media-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@omit-xml-declaration"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@omit-xml-declaration[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@standalone"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@standalone[last()] or 'omit'"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@version"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@version[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pd&gt;
                &lt;xsl:apply-templates select="$doc/*[local-name()='output' and not(@name)]/node()"/&gt;
              &lt;/pd&gt;
              &lt;xsl:for-each select="$code/xsl:output[@name]"&gt;
                &lt;xsl:if test="not(@name=preceding::xsl:output/@name)"&gt;
                  &lt;xsl:variable name="name" select="@name"/&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@method[last()] or 'undefined'"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@indent"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@indent[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-system"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-system[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-public"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-public[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@include-content-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@include-content-type[last()] or 'yes'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@encoding"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@encoding[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;UTF&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@media-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@media-type[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@omit-xml-declaration"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@omit-xml-declaration[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@standalone"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@standalone[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@version"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@version[last()] or 'undefined'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pd&gt;
                    &lt;xsl:apply-templates select="$doc/*[local-name()='output' and @name=$name]/node()"/&gt;
                  &lt;/pd&gt;
                &lt;/xsl:if&gt;
              &lt;/xsl:for-each&gt;

            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;
      &lt;/refbody&gt;

      &lt;xsl:if test="(name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform') and (count($code//xsl:include) &amp;gt; 0 or count($code//xsl:import) &amp;gt; 0 or count($doc/*[local-name()='see']) &amp;gt; 0)"&gt;
        &lt;related-links&gt;
          &lt;xsl:if test="count($code//xsl:include) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:include)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:include"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:include statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($code//xsl:import) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:import)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:import"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:import statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($doc/*[local-name()='see']) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;See also&lt;/title&gt;
              &lt;xsl:for-each select="$doc/*[local-name()='see']"&gt;
                &lt;link href="{./text()}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These are related readings suggested by the author of the XSLT
                stylesheet.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
        &lt;/related-links&gt;
      &lt;/xsl:if&gt;

      &lt;section outputclass="sourcecode"&gt;
        &lt;title outputclass="sourcecode-header"&gt;Source Code&lt;/title&gt;
        &lt;codeblock&gt;
          &lt;xsl:copy-of select="$code"/&gt;
          &lt;!--xsl:for-each select="$code"&gt;
            &lt;xsl:if test="not(self::xd:doc) and not(self::xsltdoc:doc)"&gt;
              &lt;xsl:call-template name="xml-to-string"/&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:for-each--&gt;
        &lt;/codeblock&gt;
      &lt;/section&gt;
    &lt;/reference&gt;

  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;&amp;lt;xd:code/&amp;gt; becomes &amp;lt;codeblock outputclass="language-xslt"/&amp;gt;&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="xd:code"&gt;
    &lt;codeblock outputclass="language-xslt"&gt;&lt;xsl:apply-templates/&gt;&lt;/codeblock&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;&lt;/codeblock&gt;
  &lt;xsl:template name="subdoc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="parentdoc"&gt;
      &lt;xsl:element name="xd:doc"/&gt;
    &lt;/xsl:param&gt;

    &lt;xsl:if test="not(name($code) = 'xd:doc' or name($code) = 'xsltdoc:doc')"&gt;
      &lt;xsl:for-each select="$code/*"&gt;
        &lt;xsl:choose&gt;
          &lt;!-- Don't document the documentation ;) --&gt;
          &lt;xsl:when test="name(.) = 'xd:doc' or name(.) = 'xsltdoc:doc'"/&gt;

          &lt;!-- When the current element contains a xd:doc child targeting it, use it --&gt;
          &lt;xsl:when test="./xd:doc[@target='parent'][1] and not(generate-id(./xd:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xd:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the current element contains a xs:doc child targeting it, use it --&gt;
          &lt;xsl:when test="(./xsltdoc:doc[@target='parent'][1]) and not(generate-id(./xsltdoc:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first child of the current element is a xd:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(./*[1]) = 'xd:doc' or name(./*[1]) = 'xsltdoc:doc') and not(./*[1]/@target = 'following') and not(generate-id(./*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first preceding sibling is a xs:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(preceding-sibling::*[1]) = 'xd:doc' or name(preceding-sibling::*[1]) = 'xsltdoc:doc') and not(preceding-sibling::*[1]/@target = 'parent') and not(generate-id(preceding-sibling::*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="preceding-sibling::*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- The element has no documentation, and it's not the root element so don't document it --&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:otherwise&gt;

        &lt;/xsl:choose&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;codeblock&gt;&lt;xsl:stylesheet exclude-result-prefixes="#all" version="2.0"&gt;

  &lt;xsl:output method="xml" indent="yes" encoding="UTF-8"/&gt;

  &lt;xd:doc target="parent"&gt;&lt;xd:short&gt;Transforms the input XSLT document to a DITA Reference Topic.&lt;/xd:short&gt;&lt;xd:author&gt;&lt;xd:name&gt;Jostein Austvik Jacobsen&lt;/xd:name&gt;&lt;xd:mailto&gt;josteinaj@gmail.com&lt;/xd:mailto&gt;&lt;xd:organization&gt;NLB&lt;/xd:organization&gt;&lt;/xd:author&gt;&lt;xd:copyright&gt;&lt;xd:year&gt;2010&lt;/xd:year&gt;&lt;/xd:copyright&gt;&lt;xd:version&gt;0.1&lt;/xd:version&gt;&lt;/xd:doc&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Override the "/" template in xml-to-string.xsl.&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Identity template.&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="@*|node()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Main template&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    Creates the top element &amp;lt;dita&amp;gt;, determines how to document the XSLT stylesheet
      itself, and recurses throught the code looking for xd:doc elements.
  &lt;/xd:detail&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="/*"&gt;
    &lt;dita&gt;
      &lt;xsl:choose&gt;

        &lt;!-- When the root element contains a xd:doc child targeting it, use it --&gt;
        &lt;xsl:when test="./xsltdoc:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- Same as above, but in the XSLTdoc namespace --&gt;
        &lt;xsl:when test="./xd:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xd:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- When the first child of the root element is a xd:doc and is not targeting another element, use it --&gt;
        &lt;xsl:when test="(name(./*[1])='xsltdoc:doc' or name(./*[1])='xd:doc') and not(./*[1]/@target='following')"&gt;
          &lt;xsl:variable name="parentdoc" select="./*[1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- The root element is not documented. Create some empty documentation for it. --&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc"&gt;
              &lt;xsl:element name="xd:doc"/&gt;
            &lt;/xsl:with-param&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:otherwise&gt;

      &lt;/xsl:choose&gt;
    &lt;/dita&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Recursive template that looks for xd:doc elements.&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    If there is a xd:doc belonging to the current element; document the current element
      using it. At the same time; recurse further through the script looking for more elements to be
      documented.
    
    
  &lt;/xd:detail&gt;&lt;xd:param name="code"&gt;Contains the element to be evaluted for documentation.&lt;/xd:param&gt;&lt;xd:param name="parentdoc"&gt;The xd:doc used to document the closest documented ancestor (used to
      make sure it isn't used twice).&lt;/xd:param&gt;&lt;/xd:doc&gt;
  &lt;xsl:template name="subdoc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="parentdoc"&gt;
      &lt;xsl:element name="xd:doc"/&gt;
    &lt;/xsl:param&gt;

    &lt;xsl:if test="not(name($code) = 'xd:doc' or name($code) = 'xsltdoc:doc')"&gt;
      &lt;xsl:for-each select="$code/*"&gt;
        &lt;xsl:choose&gt;
          &lt;!-- Don't document the documentation ;) --&gt;
          &lt;xsl:when test="name(.) = 'xd:doc' or name(.) = 'xsltdoc:doc'"/&gt;

          &lt;!-- When the current element contains a xd:doc child targeting it, use it --&gt;
          &lt;xsl:when test="./xd:doc[@target='parent'][1] and not(generate-id(./xd:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xd:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the current element contains a xs:doc child targeting it, use it --&gt;
          &lt;xsl:when test="(./xsltdoc:doc[@target='parent'][1]) and not(generate-id(./xsltdoc:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first child of the current element is a xd:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(./*[1]) = 'xd:doc' or name(./*[1]) = 'xsltdoc:doc') and not(./*[1]/@target = 'following') and not(generate-id(./*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first preceding sibling is a xs:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(preceding-sibling::*[1]) = 'xd:doc' or name(preceding-sibling::*[1]) = 'xsltdoc:doc') and not(preceding-sibling::*[1]/@target = 'parent') and not(generate-id(preceding-sibling::*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="preceding-sibling::*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- The element has no documentation, and it's not the root element so don't document it --&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:otherwise&gt;

        &lt;/xsl:choose&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Documents an element using its corresponding xd:doc element.&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    This is where the main action happens. Relevant bits of information are retrieved and
      structured as DITA-XML.
    
    
  &lt;/xd:detail&gt;&lt;xd:param name="code"&gt;Contains the XSLT code to be documentated.&lt;/xd:param&gt;&lt;xd:param name="doc"&gt;Contains the xd:doc used as documentation.&lt;/xd:param&gt;&lt;/xd:doc&gt;
  &lt;xsl:template name="doc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="doc" required="yes"/&gt;

    &lt;reference id="{generate-id($code)}"&gt;
      &lt;title&gt;
        &lt;xsl:value-of select="name($code)"/&gt;
        &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
        &lt;/xsl:if&gt;
      &lt;/title&gt;

      &lt;abstract&gt;
        &lt;shortdesc&gt;
          &lt;xsl:apply-templates select="$doc/*[local-name()='short']/node()"/&gt;
        &lt;/shortdesc&gt;
        &lt;xsl:apply-templates select="$doc/*[local-name()='detail']/node()"/&gt;
      &lt;/abstract&gt;

      &lt;prolog&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='author'] | $doc/*[local-name()='contributor'] | $doc/*[local-name()='maintainer']"&gt;
          &lt;author&gt;
            &lt;xsl:choose&gt;
              &lt;xsl:when test="local-name() = 'author'"&gt;
                &lt;xsl:attribute name="type"&gt;creator&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'contributor'"&gt;
                &lt;xsl:attribute name="type"&gt;contributor&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'maintainer'"&gt;
                &lt;xsl:attribute name="type"&gt;maintainer&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
            &lt;/xsl:choose&gt;
            &lt;xsl:apply-templates select="./*[local-name()='name']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='name'] and (./*[local-name()='organization'] or ./*[local-name()='mailto'])"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='organization']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='organization'] and ./*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='mailto']/node()"/&gt;
          &lt;/author&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='copyright']"&gt;

          &lt;xsl:choose&gt;
            &lt;xsl:when test="count($doc/xd:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyryear&gt;
                  &lt;xsl:attribute name="year"&gt;
                    &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='year']/node()"/&gt;
                  &lt;/xsl:attribute&gt;
                &lt;/copyryear&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="$doc/xd:copyright/*[local-name()='holder']"&gt;
                      &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='holder']/node()"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                      &lt;xsl:if test="$doc/xd:copyright/*[local-name()='name']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='name']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization' or local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='organization']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='mailto']/node()"/&gt;
                      &lt;/xsl:if&gt;
                    &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:when test="count($doc/xsltdoc:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:apply-templates select="$doc/xsltdoc:copyright/node()"/&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
          &lt;/xsl:choose&gt;
        &lt;/xsl:for-each&gt;
        &lt;metadata&gt;
          &lt;audience type="programmer" job="programming" experiencelevel="expert"/&gt;
          &lt;othermeta name="programming-language" content="XSLT"/&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='version']"&gt;
            &lt;othermeta name="version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='since']"&gt;
            &lt;othermeta name="since"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;!--xsl:for-each select="$doc/*[local-name()='see']"&gt;
            &lt;othermeta name="see"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each--&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='deprecated']"&gt;
            &lt;othermeta name="deprecated"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;

          &lt;!-- XSLT and XPath version --&gt;
          &lt;xsl:if test="name($code)='xsl:stylesheet' or name($code)='xsl:transform'"&gt;
            &lt;xsl:variable name="xslt-version" select="$code/@version | $code/@xsl:version"/&gt;
            &lt;othermeta name="xslt-version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="$xslt-version"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
            &lt;xsl:if test="$xslt-version='1.0' or $xslt-version='2.0'"&gt;
              &lt;othermeta name="xpath-version"&gt;
                &lt;xsl:attribute name="content"&gt;
                  &lt;xsl:value-of select="$xslt-version"/&gt;
                &lt;/xsl:attribute&gt;
              &lt;/othermeta&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:if&gt;

        &lt;/metadata&gt;
      &lt;/prolog&gt;

      &lt;refbody&gt;
        &lt;section&gt;
          &lt;apiname&gt;
            &lt;xsl:value-of select="name($code)"/&gt;
            &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
            &lt;/xsl:if&gt;
          &lt;/apiname&gt;
        &lt;/section&gt;

        &lt;xsl:if test="$code/xsl:param | $code/xsl:with-param"&gt;
          &lt;section outputclass="parameters xslt-params"&gt;
            &lt;title outputclass="io-header"&gt;Parameters (xsl:param / xsl:with-param)&lt;/title&gt;
            &lt;parml outputclass="xslt-params"&gt;
              &lt;xsl:choose&gt;
                &lt;xsl:when test="count($code/xsl:with-param) &amp;gt; 0"&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params xslt-with-params'"/&gt;
                &lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params'"/&gt;
                &lt;/xsl:otherwise&gt;
              &lt;/xsl:choose&gt;
              &lt;!--plentry&gt;
                &lt;pt&gt;Name&lt;/pt&gt;
                &lt;pd&gt;As&lt;/pd&gt;
                &lt;xsl:if test="count($code/xsl:with-param) &gt; 0"&gt;
                  &lt;pd&gt;Required&lt;/pd&gt;
                &lt;/xsl:if&gt;
                &lt;pd&gt;Tunnel&lt;/pd&gt;
                &lt;pd&gt;Description&lt;/pd&gt;
              &lt;/plentry--&gt;
              &lt;xsl:for-each select="$code/xsl:param | $code/xsl:with-param"&gt;
                &lt;xsl:variable name="name" select="@name"/&gt;
                &lt;plentry&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@as"&gt;
                        &lt;xsl:value-of select="@as"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;undefined&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:if test="name(.) = 'xsl:param'"&gt;
                    &lt;pt&gt;
                      &lt;xsl:choose&gt;
                        &lt;xsl:when test="name(./parent::*) = 'xsl:function' or @required = 'true'"&gt;true&lt;/xsl:when&gt;
                        &lt;xsl:otherwise&gt;false&lt;/xsl:otherwise&gt;
                      &lt;/xsl:choose&gt;
                    &lt;/pt&gt;
                  &lt;/xsl:if&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@tunnel='yes'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="name(.)='xsl:param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="name(.)='xsl:with-param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='with-param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                  &lt;/xsl:choose&gt;
                &lt;/plentry&gt;
              &lt;/xsl:for-each&gt;
            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;

        &lt;xsl:if test="name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform'"&gt;
          &lt;section outputclass="parameters xslt-outputs"&gt;
            &lt;title outputclass="io-header"&gt;Outputs (xsl:output)&lt;/title&gt;
            &lt;parml outputclass="xslt-outputs"&gt;
              &lt;xsl:attribute name="outputclass" select="'xslt-outputs'"/&gt;
              &lt;!--
              name
              method
              indent
              doctype-system
              doctype-public
              include-content-type
              encoding
              media-type
              omit-xml-declaration
              standalone
              version
              comments
              --&gt;
              &lt;pt/&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@method"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@method[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@indent"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@indent[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-system"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-system[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-public"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-public[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@include-content-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@include-content-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@encoding"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@encoding[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;UTF-8/UTF-16&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@media-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@media-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@omit-xml-declaration"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@omit-xml-declaration[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@standalone"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@standalone[last()] or 'omit'"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@version"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@version[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pd&gt;
                &lt;xsl:apply-templates select="$doc/*[local-name()='output' and not(@name)]/node()"/&gt;
              &lt;/pd&gt;
              &lt;xsl:for-each select="$code/xsl:output[@name]"&gt;
                &lt;xsl:if test="not(@name=preceding::xsl:output/@name)"&gt;
                  &lt;xsl:variable name="name" select="@name"/&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@method[last()] or 'undefined'"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@indent"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@indent[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-system"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-system[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-public"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-public[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@include-content-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@include-content-type[last()] or 'yes'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@encoding"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@encoding[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;UTF&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@media-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@media-type[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@omit-xml-declaration"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@omit-xml-declaration[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@standalone"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@standalone[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@version"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@version[last()] or 'undefined'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pd&gt;
                    &lt;xsl:apply-templates select="$doc/*[local-name()='output' and @name=$name]/node()"/&gt;
                  &lt;/pd&gt;
                &lt;/xsl:if&gt;
              &lt;/xsl:for-each&gt;

            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;
      &lt;/refbody&gt;

      &lt;xsl:if test="(name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform') and (count($code//xsl:include) &amp;gt; 0 or count($code//xsl:import) &amp;gt; 0 or count($doc/*[local-name()='see']) &amp;gt; 0)"&gt;
        &lt;related-links&gt;
          &lt;xsl:if test="count($code//xsl:include) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:include)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:include"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:include statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($code//xsl:import) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:import)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:import"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:import statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($doc/*[local-name()='see']) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;See also&lt;/title&gt;
              &lt;xsl:for-each select="$doc/*[local-name()='see']"&gt;
                &lt;link href="{./text()}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These are related readings suggested by the author of the XSLT
                stylesheet.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
        &lt;/related-links&gt;
      &lt;/xsl:if&gt;

      &lt;section outputclass="sourcecode"&gt;
        &lt;title outputclass="sourcecode-header"&gt;Source Code&lt;/title&gt;
        &lt;codeblock&gt;
          &lt;xsl:copy-of select="$code"/&gt;
          &lt;!--xsl:for-each select="$code"&gt;
            &lt;xsl:if test="not(self::xd:doc) and not(self::xsltdoc:doc)"&gt;
              &lt;xsl:call-template name="xml-to-string"/&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:for-each--&gt;
        &lt;/codeblock&gt;
      &lt;/section&gt;
    &lt;/reference&gt;

  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;&amp;lt;xd:code/&amp;gt; becomes &amp;lt;codeblock outputclass="language-xslt"/&amp;gt;&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="xd:code"&gt;
    &lt;codeblock outputclass="language-xslt"&gt;&lt;xsl:apply-templates/&gt;&lt;/codeblock&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;&lt;/codeblock&gt;
  &lt;xsl:template name="doc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="doc" required="yes"/&gt;

    &lt;reference id="{generate-id($code)}"&gt;
      &lt;title&gt;
        &lt;xsl:value-of select="name($code)"/&gt;
        &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
        &lt;/xsl:if&gt;
      &lt;/title&gt;

      &lt;abstract&gt;
        &lt;shortdesc&gt;
          &lt;xsl:apply-templates select="$doc/*[local-name()='short']/node()"/&gt;
        &lt;/shortdesc&gt;
        &lt;xsl:apply-templates select="$doc/*[local-name()='detail']/node()"/&gt;
      &lt;/abstract&gt;

      &lt;prolog&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='author'] | $doc/*[local-name()='contributor'] | $doc/*[local-name()='maintainer']"&gt;
          &lt;author&gt;
            &lt;xsl:choose&gt;
              &lt;xsl:when test="local-name() = 'author'"&gt;
                &lt;xsl:attribute name="type"&gt;creator&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'contributor'"&gt;
                &lt;xsl:attribute name="type"&gt;contributor&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'maintainer'"&gt;
                &lt;xsl:attribute name="type"&gt;maintainer&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
            &lt;/xsl:choose&gt;
            &lt;xsl:apply-templates select="./*[local-name()='name']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='name'] and (./*[local-name()='organization'] or ./*[local-name()='mailto'])"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='organization']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='organization'] and ./*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='mailto']/node()"/&gt;
          &lt;/author&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='copyright']"&gt;

          &lt;xsl:choose&gt;
            &lt;xsl:when test="count($doc/xd:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyryear&gt;
                  &lt;xsl:attribute name="year"&gt;
                    &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='year']/node()"/&gt;
                  &lt;/xsl:attribute&gt;
                &lt;/copyryear&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="$doc/xd:copyright/*[local-name()='holder']"&gt;
                      &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='holder']/node()"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                      &lt;xsl:if test="$doc/xd:copyright/*[local-name()='name']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='name']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization' or local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='organization']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='mailto']/node()"/&gt;
                      &lt;/xsl:if&gt;
                    &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:when test="count($doc/xsltdoc:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:apply-templates select="$doc/xsltdoc:copyright/node()"/&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
          &lt;/xsl:choose&gt;
        &lt;/xsl:for-each&gt;
        &lt;metadata&gt;
          &lt;audience type="programmer" job="programming" experiencelevel="expert"/&gt;
          &lt;othermeta name="programming-language" content="XSLT"/&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='version']"&gt;
            &lt;othermeta name="version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='since']"&gt;
            &lt;othermeta name="since"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;!--xsl:for-each select="$doc/*[local-name()='see']"&gt;
            &lt;othermeta name="see"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each--&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='deprecated']"&gt;
            &lt;othermeta name="deprecated"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;

          &lt;!-- XSLT and XPath version --&gt;
          &lt;xsl:if test="name($code)='xsl:stylesheet' or name($code)='xsl:transform'"&gt;
            &lt;xsl:variable name="xslt-version" select="$code/@version | $code/@xsl:version"/&gt;
            &lt;othermeta name="xslt-version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="$xslt-version"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
            &lt;xsl:if test="$xslt-version='1.0' or $xslt-version='2.0'"&gt;
              &lt;othermeta name="xpath-version"&gt;
                &lt;xsl:attribute name="content"&gt;
                  &lt;xsl:value-of select="$xslt-version"/&gt;
                &lt;/xsl:attribute&gt;
              &lt;/othermeta&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:if&gt;

        &lt;/metadata&gt;
      &lt;/prolog&gt;

      &lt;refbody&gt;
        &lt;section&gt;
          &lt;apiname&gt;
            &lt;xsl:value-of select="name($code)"/&gt;
            &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
            &lt;/xsl:if&gt;
          &lt;/apiname&gt;
        &lt;/section&gt;

        &lt;xsl:if test="$code/xsl:param | $code/xsl:with-param"&gt;
          &lt;section outputclass="parameters xslt-params"&gt;
            &lt;title outputclass="io-header"&gt;Parameters (xsl:param / xsl:with-param)&lt;/title&gt;
            &lt;parml outputclass="xslt-params"&gt;
              &lt;xsl:choose&gt;
                &lt;xsl:when test="count($code/xsl:with-param) &amp;gt; 0"&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params xslt-with-params'"/&gt;
                &lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params'"/&gt;
                &lt;/xsl:otherwise&gt;
              &lt;/xsl:choose&gt;
              &lt;!--plentry&gt;
                &lt;pt&gt;Name&lt;/pt&gt;
                &lt;pd&gt;As&lt;/pd&gt;
                &lt;xsl:if test="count($code/xsl:with-param) &gt; 0"&gt;
                  &lt;pd&gt;Required&lt;/pd&gt;
                &lt;/xsl:if&gt;
                &lt;pd&gt;Tunnel&lt;/pd&gt;
                &lt;pd&gt;Description&lt;/pd&gt;
              &lt;/plentry--&gt;
              &lt;xsl:for-each select="$code/xsl:param | $code/xsl:with-param"&gt;
                &lt;xsl:variable name="name" select="@name"/&gt;
                &lt;plentry&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@as"&gt;
                        &lt;xsl:value-of select="@as"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;undefined&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:if test="name(.) = 'xsl:param'"&gt;
                    &lt;pt&gt;
                      &lt;xsl:choose&gt;
                        &lt;xsl:when test="name(./parent::*) = 'xsl:function' or @required = 'true'"&gt;true&lt;/xsl:when&gt;
                        &lt;xsl:otherwise&gt;false&lt;/xsl:otherwise&gt;
                      &lt;/xsl:choose&gt;
                    &lt;/pt&gt;
                  &lt;/xsl:if&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@tunnel='yes'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="name(.)='xsl:param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="name(.)='xsl:with-param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='with-param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                  &lt;/xsl:choose&gt;
                &lt;/plentry&gt;
              &lt;/xsl:for-each&gt;
            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;

        &lt;xsl:if test="name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform'"&gt;
          &lt;section outputclass="parameters xslt-outputs"&gt;
            &lt;title outputclass="io-header"&gt;Outputs (xsl:output)&lt;/title&gt;
            &lt;parml outputclass="xslt-outputs"&gt;
              &lt;xsl:attribute name="outputclass" select="'xslt-outputs'"/&gt;
              &lt;!--
              name
              method
              indent
              doctype-system
              doctype-public
              include-content-type
              encoding
              media-type
              omit-xml-declaration
              standalone
              version
              comments
              --&gt;
              &lt;pt/&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@method"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@method[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@indent"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@indent[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-system"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-system[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-public"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-public[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@include-content-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@include-content-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@encoding"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@encoding[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;UTF-8/UTF-16&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@media-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@media-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@omit-xml-declaration"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@omit-xml-declaration[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@standalone"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@standalone[last()] or 'omit'"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@version"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@version[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pd&gt;
                &lt;xsl:apply-templates select="$doc/*[local-name()='output' and not(@name)]/node()"/&gt;
              &lt;/pd&gt;
              &lt;xsl:for-each select="$code/xsl:output[@name]"&gt;
                &lt;xsl:if test="not(@name=preceding::xsl:output/@name)"&gt;
                  &lt;xsl:variable name="name" select="@name"/&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@method[last()] or 'undefined'"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@indent"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@indent[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-system"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-system[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-public"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-public[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@include-content-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@include-content-type[last()] or 'yes'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@encoding"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@encoding[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;UTF&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@media-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@media-type[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@omit-xml-declaration"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@omit-xml-declaration[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@standalone"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@standalone[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@version"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@version[last()] or 'undefined'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pd&gt;
                    &lt;xsl:apply-templates select="$doc/*[local-name()='output' and @name=$name]/node()"/&gt;
                  &lt;/pd&gt;
                &lt;/xsl:if&gt;
              &lt;/xsl:for-each&gt;

            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;
      &lt;/refbody&gt;

      &lt;xsl:if test="(name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform') and (count($code//xsl:include) &amp;gt; 0 or count($code//xsl:import) &amp;gt; 0 or count($doc/*[local-name()='see']) &amp;gt; 0)"&gt;
        &lt;related-links&gt;
          &lt;xsl:if test="count($code//xsl:include) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:include)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:include"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:include statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($code//xsl:import) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:import)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:import"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:import statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($doc/*[local-name()='see']) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;See also&lt;/title&gt;
              &lt;xsl:for-each select="$doc/*[local-name()='see']"&gt;
                &lt;link href="{./text()}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These are related readings suggested by the author of the XSLT
                stylesheet.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
        &lt;/related-links&gt;
      &lt;/xsl:if&gt;

      &lt;section outputclass="sourcecode"&gt;
        &lt;title outputclass="sourcecode-header"&gt;Source Code&lt;/title&gt;
        &lt;codeblock&gt;
          &lt;xsl:copy-of select="$code"/&gt;
          &lt;!--xsl:for-each select="$code"&gt;
            &lt;xsl:if test="not(self::xd:doc) and not(self::xsltdoc:doc)"&gt;
              &lt;xsl:call-template name="xml-to-string"/&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:for-each--&gt;
        &lt;/codeblock&gt;
      &lt;/section&gt;
    &lt;/reference&gt;

  &lt;/xsl:template&gt;

  &lt;codeblock&gt;&lt;xsl:stylesheet exclude-result-prefixes="#all" version="2.0"&gt;

  &lt;xsl:output method="xml" indent="yes" encoding="UTF-8"/&gt;

  &lt;xd:doc target="parent"&gt;&lt;xd:short&gt;Transforms the input XSLT document to a DITA Reference Topic.&lt;/xd:short&gt;&lt;xd:author&gt;&lt;xd:name&gt;Jostein Austvik Jacobsen&lt;/xd:name&gt;&lt;xd:mailto&gt;josteinaj@gmail.com&lt;/xd:mailto&gt;&lt;xd:organization&gt;NLB&lt;/xd:organization&gt;&lt;/xd:author&gt;&lt;xd:copyright&gt;&lt;xd:year&gt;2010&lt;/xd:year&gt;&lt;/xd:copyright&gt;&lt;xd:version&gt;0.1&lt;/xd:version&gt;&lt;/xd:doc&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Override the "/" template in xml-to-string.xsl.&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Identity template.&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="@*|node()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Main template&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    Creates the top element &amp;lt;dita&amp;gt;, determines how to document the XSLT stylesheet
      itself, and recurses throught the code looking for xd:doc elements.
  &lt;/xd:detail&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="/*"&gt;
    &lt;dita&gt;
      &lt;xsl:choose&gt;

        &lt;!-- When the root element contains a xd:doc child targeting it, use it --&gt;
        &lt;xsl:when test="./xsltdoc:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- Same as above, but in the XSLTdoc namespace --&gt;
        &lt;xsl:when test="./xd:doc[@target='parent']"&gt;
          &lt;xsl:variable name="parentdoc" select="./xd:doc[@target='parent'][1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- When the first child of the root element is a xd:doc and is not targeting another element, use it --&gt;
        &lt;xsl:when test="(name(./*[1])='xsltdoc:doc' or name(./*[1])='xd:doc') and not(./*[1]/@target='following')"&gt;
          &lt;xsl:variable name="parentdoc" select="./*[1]"/&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc" select="$parentdoc"/&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
            &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;

        &lt;!-- The root element is not documented. Create some empty documentation for it. --&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:call-template name="doc"&gt;
            &lt;xsl:with-param name="doc"&gt;
              &lt;xsl:element name="xd:doc"/&gt;
            &lt;/xsl:with-param&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
          &lt;xsl:call-template name="subdoc"&gt;
            &lt;xsl:with-param name="code" select="."/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:otherwise&gt;

      &lt;/xsl:choose&gt;
    &lt;/dita&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Recursive template that looks for xd:doc elements.&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    If there is a xd:doc belonging to the current element; document the current element
      using it. At the same time; recurse further through the script looking for more elements to be
      documented.
    
    
  &lt;/xd:detail&gt;&lt;xd:param name="code"&gt;Contains the element to be evaluted for documentation.&lt;/xd:param&gt;&lt;xd:param name="parentdoc"&gt;The xd:doc used to document the closest documented ancestor (used to
      make sure it isn't used twice).&lt;/xd:param&gt;&lt;/xd:doc&gt;
  &lt;xsl:template name="subdoc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="parentdoc"&gt;
      &lt;xsl:element name="xd:doc"/&gt;
    &lt;/xsl:param&gt;

    &lt;xsl:if test="not(name($code) = 'xd:doc' or name($code) = 'xsltdoc:doc')"&gt;
      &lt;xsl:for-each select="$code/*"&gt;
        &lt;xsl:choose&gt;
          &lt;!-- Don't document the documentation ;) --&gt;
          &lt;xsl:when test="name(.) = 'xd:doc' or name(.) = 'xsltdoc:doc'"/&gt;

          &lt;!-- When the current element contains a xd:doc child targeting it, use it --&gt;
          &lt;xsl:when test="./xd:doc[@target='parent'][1] and not(generate-id(./xd:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xd:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the current element contains a xs:doc child targeting it, use it --&gt;
          &lt;xsl:when test="(./xsltdoc:doc[@target='parent'][1]) and not(generate-id(./xsltdoc:doc[@target='parent'][1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./xsltdoc:doc[@target='parent'][1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first child of the current element is a xd:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(./*[1]) = 'xd:doc' or name(./*[1]) = 'xsltdoc:doc') and not(./*[1]/@target = 'following') and not(generate-id(./*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="./*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- When the first preceding sibling is a xs:doc and is not targeting another element, use it --&gt;
          &lt;xsl:when test="(name(preceding-sibling::*[1]) = 'xd:doc' or name(preceding-sibling::*[1]) = 'xsltdoc:doc') and not(preceding-sibling::*[1]/@target = 'parent') and not(generate-id(preceding-sibling::*[1]) = generate-id($parentdoc))"&gt;
            &lt;xsl:variable name="doc" select="preceding-sibling::*[1]"/&gt;
            &lt;xsl:call-template name="doc"&gt;
              &lt;xsl:with-param name="doc" select="$doc"/&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
            &lt;/xsl:call-template&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$doc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;

          &lt;!-- The element has no documentation, and it's not the root element so don't document it --&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:call-template name="subdoc"&gt;
              &lt;xsl:with-param name="code" select="."/&gt;
              &lt;xsl:with-param name="parentdoc" select="$parentdoc"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:otherwise&gt;

        &lt;/xsl:choose&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;Documents an element using its corresponding xd:doc element.&lt;/xd:short&gt;&lt;xd:detail&gt;
    
    This is where the main action happens. Relevant bits of information are retrieved and
      structured as DITA-XML.
    
    
  &lt;/xd:detail&gt;&lt;xd:param name="code"&gt;Contains the XSLT code to be documentated.&lt;/xd:param&gt;&lt;xd:param name="doc"&gt;Contains the xd:doc used as documentation.&lt;/xd:param&gt;&lt;/xd:doc&gt;
  &lt;xsl:template name="doc"&gt;
    &lt;xsl:param name="code" required="yes"/&gt;
    &lt;xsl:param name="doc" required="yes"/&gt;

    &lt;reference id="{generate-id($code)}"&gt;
      &lt;title&gt;
        &lt;xsl:value-of select="name($code)"/&gt;
        &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
        &lt;/xsl:if&gt;
      &lt;/title&gt;

      &lt;abstract&gt;
        &lt;shortdesc&gt;
          &lt;xsl:apply-templates select="$doc/*[local-name()='short']/node()"/&gt;
        &lt;/shortdesc&gt;
        &lt;xsl:apply-templates select="$doc/*[local-name()='detail']/node()"/&gt;
      &lt;/abstract&gt;

      &lt;prolog&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='author'] | $doc/*[local-name()='contributor'] | $doc/*[local-name()='maintainer']"&gt;
          &lt;author&gt;
            &lt;xsl:choose&gt;
              &lt;xsl:when test="local-name() = 'author'"&gt;
                &lt;xsl:attribute name="type"&gt;creator&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'contributor'"&gt;
                &lt;xsl:attribute name="type"&gt;contributor&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:when test="local-name() = 'maintainer'"&gt;
                &lt;xsl:attribute name="type"&gt;maintainer&lt;/xsl:attribute&gt;
              &lt;/xsl:when&gt;
            &lt;/xsl:choose&gt;
            &lt;xsl:apply-templates select="./*[local-name()='name']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='name'] and (./*[local-name()='organization'] or ./*[local-name()='mailto'])"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='organization']/node()"/&gt;
            &lt;xsl:if test="./*[local-name()='organization'] and ./*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
            &lt;xsl:apply-templates select="./*[local-name()='mailto']/node()"/&gt;
          &lt;/author&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:for-each select="$doc/*[local-name()='copyright']"&gt;

          &lt;xsl:choose&gt;
            &lt;xsl:when test="count($doc/xd:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyryear&gt;
                  &lt;xsl:attribute name="year"&gt;
                    &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='year']/node()"/&gt;
                  &lt;/xsl:attribute&gt;
                &lt;/copyryear&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="$doc/xd:copyright/*[local-name()='holder']"&gt;
                      &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='holder']/node()"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                      &lt;xsl:if test="$doc/xd:copyright/*[local-name()='name']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='name']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization' or local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='organization']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='organization']/node()"/&gt;
                        &lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;, &lt;/xsl:if&gt;
                      &lt;/xsl:if&gt;&lt;xsl:if test="$doc/xd:copyright/*[local-name()='mailto']"&gt;
                        &lt;xsl:apply-templates select="$doc/xd:copyright/*[local-name()='mailto']/node()"/&gt;
                      &lt;/xsl:if&gt;
                    &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:when test="count($doc/xsltdoc:copyright)&amp;gt;0"&gt;
              &lt;copyright&gt;
                &lt;copyrholder&gt;
                  &lt;xsl:apply-templates select="$doc/xsltdoc:copyright/node()"/&gt;
                &lt;/copyrholder&gt;
              &lt;/copyright&gt;
            &lt;/xsl:when&gt;
          &lt;/xsl:choose&gt;
        &lt;/xsl:for-each&gt;
        &lt;metadata&gt;
          &lt;audience type="programmer" job="programming" experiencelevel="expert"/&gt;
          &lt;othermeta name="programming-language" content="XSLT"/&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='version']"&gt;
            &lt;othermeta name="version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='since']"&gt;
            &lt;othermeta name="since"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;
          &lt;!--xsl:for-each select="$doc/*[local-name()='see']"&gt;
            &lt;othermeta name="see"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each--&gt;
          &lt;xsl:for-each select="$doc/*[local-name()='deprecated']"&gt;
            &lt;othermeta name="deprecated"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="./text()"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
          &lt;/xsl:for-each&gt;

          &lt;!-- XSLT and XPath version --&gt;
          &lt;xsl:if test="name($code)='xsl:stylesheet' or name($code)='xsl:transform'"&gt;
            &lt;xsl:variable name="xslt-version" select="$code/@version | $code/@xsl:version"/&gt;
            &lt;othermeta name="xslt-version"&gt;
              &lt;xsl:attribute name="content"&gt;
                &lt;xsl:value-of select="$xslt-version"/&gt;
              &lt;/xsl:attribute&gt;
            &lt;/othermeta&gt;
            &lt;xsl:if test="$xslt-version='1.0' or $xslt-version='2.0'"&gt;
              &lt;othermeta name="xpath-version"&gt;
                &lt;xsl:attribute name="content"&gt;
                  &lt;xsl:value-of select="$xslt-version"/&gt;
                &lt;/xsl:attribute&gt;
              &lt;/othermeta&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:if&gt;

        &lt;/metadata&gt;
      &lt;/prolog&gt;

      &lt;refbody&gt;
        &lt;section&gt;
          &lt;apiname&gt;
            &lt;xsl:value-of select="name($code)"/&gt;
            &lt;xsl:if test="$code/@name"&gt; - &lt;xsl:value-of select="$code/@name"/&gt;
            &lt;/xsl:if&gt;
          &lt;/apiname&gt;
        &lt;/section&gt;

        &lt;xsl:if test="$code/xsl:param | $code/xsl:with-param"&gt;
          &lt;section outputclass="parameters xslt-params"&gt;
            &lt;title outputclass="io-header"&gt;Parameters (xsl:param / xsl:with-param)&lt;/title&gt;
            &lt;parml outputclass="xslt-params"&gt;
              &lt;xsl:choose&gt;
                &lt;xsl:when test="count($code/xsl:with-param) &amp;gt; 0"&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params xslt-with-params'"/&gt;
                &lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt;
                  &lt;xsl:attribute name="outputclass" select="'xslt-params'"/&gt;
                &lt;/xsl:otherwise&gt;
              &lt;/xsl:choose&gt;
              &lt;!--plentry&gt;
                &lt;pt&gt;Name&lt;/pt&gt;
                &lt;pd&gt;As&lt;/pd&gt;
                &lt;xsl:if test="count($code/xsl:with-param) &gt; 0"&gt;
                  &lt;pd&gt;Required&lt;/pd&gt;
                &lt;/xsl:if&gt;
                &lt;pd&gt;Tunnel&lt;/pd&gt;
                &lt;pd&gt;Description&lt;/pd&gt;
              &lt;/plentry--&gt;
              &lt;xsl:for-each select="$code/xsl:param | $code/xsl:with-param"&gt;
                &lt;xsl:variable name="name" select="@name"/&gt;
                &lt;plentry&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@as"&gt;
                        &lt;xsl:value-of select="@as"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;undefined&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:if test="name(.) = 'xsl:param'"&gt;
                    &lt;pt&gt;
                      &lt;xsl:choose&gt;
                        &lt;xsl:when test="name(./parent::*) = 'xsl:function' or @required = 'true'"&gt;true&lt;/xsl:when&gt;
                        &lt;xsl:otherwise&gt;false&lt;/xsl:otherwise&gt;
                      &lt;/xsl:choose&gt;
                    &lt;/pt&gt;
                  &lt;/xsl:if&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="@tunnel='yes'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="name(.)='xsl:param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="name(.)='xsl:with-param'"&gt;
                      &lt;pd&gt;
                        &lt;xsl:variable name="name" select="@name"/&gt;
                        &lt;xsl:apply-templates select="$doc/*[local-name()='with-param'][@name=$name]/node()"/&gt;
                      &lt;/pd&gt;
                    &lt;/xsl:when&gt;
                  &lt;/xsl:choose&gt;
                &lt;/plentry&gt;
              &lt;/xsl:for-each&gt;
            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;

        &lt;xsl:if test="name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform'"&gt;
          &lt;section outputclass="parameters xslt-outputs"&gt;
            &lt;title outputclass="io-header"&gt;Outputs (xsl:output)&lt;/title&gt;
            &lt;parml outputclass="xslt-outputs"&gt;
              &lt;xsl:attribute name="outputclass" select="'xslt-outputs'"/&gt;
              &lt;!--
              name
              method
              indent
              doctype-system
              doctype-public
              include-content-type
              encoding
              media-type
              omit-xml-declaration
              standalone
              version
              comments
              --&gt;
              &lt;pt/&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@method"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@method[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@indent"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@indent[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-system"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-system[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@doctype-public"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@doctype-public[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@include-content-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@include-content-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;

              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@encoding"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@encoding[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;UTF-8/UTF-16&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@media-type"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@media-type[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'html' or lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                  &lt;xsl:when test="lower-case($code/xsl:output[not(@name)]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@omit-xml-declaration"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@omit-xml-declaration[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@standalone"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@standalone[last()] or 'omit'"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pt&gt;
                &lt;xsl:choose&gt;
                  &lt;xsl:when test="$code/xsl:output[not(@name)]/@version"&gt;
                    &lt;xsl:value-of select="$code/xsl:output[not(@name)]/@version[last()]"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise/&gt;
                &lt;/xsl:choose&gt;
              &lt;/pt&gt;
              &lt;pd&gt;
                &lt;xsl:apply-templates select="$doc/*[local-name()='output' and not(@name)]/node()"/&gt;
              &lt;/pd&gt;
              &lt;xsl:for-each select="$code/xsl:output[@name]"&gt;
                &lt;xsl:if test="not(@name=preceding::xsl:output/@name)"&gt;
                  &lt;xsl:variable name="name" select="@name"/&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$name"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@method[last()] or 'undefined'"/&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@indent"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@indent[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;no&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;yes&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-system"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-system[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@doctype-public"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@doctype-public[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@include-content-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@include-content-type[last()] or 'yes'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;yes&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@encoding"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@encoding[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;UTF&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@media-type"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@media-type[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xml'"&gt;text/xml&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'html' or lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'xhtml'"&gt;text/html&lt;/xsl:when&gt;
                      &lt;xsl:when test="lower-case($code/xsl:output[@name=$name]/@method[last()]) = 'text'"&gt;text/plain&lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@omit-xml-declaration"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@omit-xml-declaration[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;no&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@standalone"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@standalone[last()]"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise&gt;omit&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pt&gt;
                    &lt;xsl:choose&gt;
                      &lt;xsl:when test="$code/xsl:output[@name=$name]/@version"&gt;
                        &lt;xsl:value-of select="$code/xsl:output[@name=$name]/@version[last()] or 'undefined'"/&gt;
                      &lt;/xsl:when&gt;
                      &lt;xsl:otherwise/&gt;
                    &lt;/xsl:choose&gt;
                  &lt;/pt&gt;
                  &lt;pd&gt;
                    &lt;xsl:apply-templates select="$doc/*[local-name()='output' and @name=$name]/node()"/&gt;
                  &lt;/pd&gt;
                &lt;/xsl:if&gt;
              &lt;/xsl:for-each&gt;

            &lt;/parml&gt;
          &lt;/section&gt;
        &lt;/xsl:if&gt;
      &lt;/refbody&gt;

      &lt;xsl:if test="(name($code) = 'xsl:stylesheet' or name($code) = 'xsl:transform') and (count($code//xsl:include) &amp;gt; 0 or count($code//xsl:import) &amp;gt; 0 or count($doc/*[local-name()='see']) &amp;gt; 0)"&gt;
        &lt;related-links&gt;
          &lt;xsl:if test="count($code//xsl:include) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:include)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:include"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:include statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($code//xsl:import) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;Dependencies (xsl:import)&lt;/title&gt;
              &lt;xsl:for-each select="$code//xsl:import"&gt;
                &lt;link href="{@href}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These dependencies are derived from the xsl:import statements.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="count($doc/*[local-name()='see']) &amp;gt; 0"&gt;
            &lt;linklist&gt;
              &lt;title&gt;See also&lt;/title&gt;
              &lt;xsl:for-each select="$doc/*[local-name()='see']"&gt;
                &lt;link href="{./text()}" format="ditamap"/&gt;
              &lt;/xsl:for-each&gt;
              &lt;linkinfo&gt;These are related readings suggested by the author of the XSLT
                stylesheet.&lt;/linkinfo&gt;
            &lt;/linklist&gt;
          &lt;/xsl:if&gt;
        &lt;/related-links&gt;
      &lt;/xsl:if&gt;

      &lt;section outputclass="sourcecode"&gt;
        &lt;title outputclass="sourcecode-header"&gt;Source Code&lt;/title&gt;
        &lt;codeblock&gt;
          &lt;xsl:copy-of select="$code"/&gt;
          &lt;!--xsl:for-each select="$code"&gt;
            &lt;xsl:if test="not(self::xd:doc) and not(self::xsltdoc:doc)"&gt;
              &lt;xsl:call-template name="xml-to-string"/&gt;
            &lt;/xsl:if&gt;
          &lt;/xsl:for-each--&gt;
        &lt;/codeblock&gt;
      &lt;/section&gt;
    &lt;/reference&gt;

  &lt;/xsl:template&gt;

  &lt;xd:doc target="following"&gt;&lt;xd:short&gt;&amp;lt;xd:code/&amp;gt; becomes &amp;lt;codeblock outputclass="language-xslt"/&amp;gt;&lt;/xd:short&gt;&lt;/xd:doc&gt;
  &lt;xsl:template match="xd:code"&gt;
    &lt;codeblock outputclass="language-xslt"&gt;&lt;xsl:apply-templates/&gt;&lt;/codeblock&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;&lt;/codeblock&gt;
  &lt;xsl:template match="xd:code"&gt;
    &lt;codeblock outputclass="language-xslt"&gt;&lt;xsl:apply-templates/&gt;&lt;/codeblock&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</codeblock>
   </section>
</reference>